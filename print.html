<!DOCTYPE HTML>
<html lang="en">
    <head>
        <meta charset="UTF-8">
        <title>Application development - </title>
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">

        <base href="">

        <link rel="stylesheet" href="book.css">
        <link href="https://fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800" rel="stylesheet" type="text/css">
        <link href="https://fonts.googleapis.com/css?family=Source+Code+Pro:500" rel="stylesheet" type="text/css">

        <link rel="shortcut icon" href="favicon.png">

        <!-- Font Awesome -->
        <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/font-awesome/4.3.0/css/font-awesome.min.css">

        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">

        <!-- MathJax -->
        <script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>

        <!-- Fetch JQuery from CDN but have a local fallback -->
        <script src="https://code.jquery.com/jquery-2.1.4.min.js"></script>
        <script>
            if (typeof jQuery == 'undefined') {
                document.write(unescape("%3Cscript src='jquery.js'%3E%3C/script%3E"));
            }
        </script>
    </head>
    <body class="light">
        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme = localStorage.getItem('theme');
            if (theme == null) { theme = 'light'; }
            $('body').removeClass().addClass(theme);
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var sidebar = localStorage.getItem('sidebar');
            if (sidebar === "hidden") { $("html").addClass("sidebar-hidden") }
            else if (sidebar === "visible") { $("html").addClass("sidebar-visible") }
        </script>

        <div id="sidebar" class="sidebar">
            <ul class="chapter"><li class="affix"><a href="intro.html">Table of Contents</a></li><li class="affix"><a href="about.html">About</a></li><li><a href="basics.html"><strong>1.</strong> Basics</a></li><li><a href="encoding.html"><strong>2.</strong> Encoding</a></li><li><a href="concurrency.html"><strong>3.</strong> Concurrency</a></li><li><a href="net.html"><strong>4.</strong> Networking</a></li><li><a href="app.html"><strong>5.</strong> Application development</a></li></ul>
        </div>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar" class="menu-bar">
                    <div class="left-buttons">
                        <i id="sidebar-toggle" class="fa fa-bars"></i>
                        <!-- START - Rust Cookbook customization -->
                        <i id="edit-button" class="fa fa-edit">Edit</i>
                        <!-- END - Rust Cookbook customization -->
                        <i id="theme-toggle" class="fa fa-paint-brush"></i>
                    </div>

                    <h1 class="menu-title"></h1>

                    <div class="right-buttons">
                        <i id="print-button" class="fa fa-print" title="Print this book"></i>
                    </div>
                </div>

                <div id="content" class="content">
                    <a class="header" href="print.html#cookin-with-rust" id="cookin-with-rust"><h1>Cookin' with Rust</h1></a>
<p>This <em>Rust Cookbook</em> is a collection of
simple examples that demonstrate good practices to accomplish common
programming tasks, using the crates of the Rust ecosystem.</p>
<p><a href="about.html">Read more about <em>Rust Cookbook</em></a>, including tips for
how to read the book, how to use the examples, and notes on conventions.</p>
<a class="header" href="print.html#contributing" id="contributing"><h2>Contributing</h2></a>
<p>This project is intended to be easy for new Rust programmers to
contribute to, and an easy to way get involved with the Rust
community. It needs and welcomes help. For details see
<a href="https://github.com/brson/rust-cookbook/blob/master/CONTRIBUTING.md">CONTRIBUTING.md</a>.</p>
<a class="header" href="print.html#a-hrefbasicshtmlbasicsa" id="a-hrefbasicshtmlbasicsa"><h2><a href="basics.html">Basics</a></h2></a>
<table><thead><tr><th> Recipe </th><th> Crates </th><th> Categories </th></tr></thead><tbody>
<tr><td> <a href="basics.html#ex-std-read-lines">Read lines of strings from a file</a> </td><td> <a href="https://doc.rust-lang.org/std"><img src="https://img.shields.io/badge/std-1.17.0-blue.svg" alt="std-badge" /></a> </td><td> <a href="https://crates.io/categories/filesystem"><img src="https://img.shields.io/badge/-filesystem-red.svg" alt="cat-filesystem-badge" /></a> </td></tr>
<tr><td> <a href="basics.html#ex-byteorder-le">Read and write integers in little-endian byte order</a> </td><td> <a href="https://docs.rs/byteorder/"><img src="https://img.shields.io/crates/v/byteorder.svg?label=byteorder" alt="byteorder-badge" /></a> </td><td> <a href="https://crates.io/categories/encoding"><img src="https://img.shields.io/badge/-encoding-red.svg" alt="cat-encoding-badge" /></a> </td></tr>
<tr><td> <a href="basics.html#ex-rand-float">Generate random floating point numbers</a> </td><td> <a href="https://docs.rs/rand/"><img src="https://img.shields.io/crates/v/rand.svg?label=rand" alt="rand-badge" /></a> </td><td> <a href="https://crates.io/categories/science"><img src="https://img.shields.io/badge/-science-red.svg" alt="cat-science-badge" /></a> </td></tr>
<tr><td> <a href="basics.html#ex-rand-range">Generate random numbers within a range</a> </td><td> <a href="https://docs.rs/rand/"><img src="https://img.shields.io/crates/v/rand.svg?label=rand" alt="rand-badge" /></a> </td><td> <a href="https://crates.io/categories/science"><img src="https://img.shields.io/badge/-science-red.svg" alt="cat-science-badge" /></a> </td></tr>
<tr><td> <a href="basics.html#ex-rand-dist">Generate random numbers with normal distribution</a> </td><td> <a href="https://docs.rs/rand/"><img src="https://img.shields.io/crates/v/rand.svg?label=rand" alt="rand-badge" /></a> </td><td> <a href="https://crates.io/categories/science"><img src="https://img.shields.io/badge/-science-red.svg" alt="cat-science-badge" /></a> </td></tr>
<tr><td> <a href="basics.html#ex-rand-custom">Generate random values of a custom type</a> </td><td> <a href="https://docs.rs/rand/"><img src="https://img.shields.io/crates/v/rand.svg?label=rand" alt="rand-badge" /></a> </td><td> <a href="https://crates.io/categories/science"><img src="https://img.shields.io/badge/-science-red.svg" alt="cat-science-badge" /></a> </td></tr>
<tr><td> <a href="basics.html#ex-parse-subprocess-output">Run an External Command and Process Stdout</a> </td><td> <a href="https://docs.rs/regex/"><img src="https://img.shields.io/crates/v/regex.svg?label=regex" alt="regex-badge" /></a> </td><td> <a href="https://crates.io/categories/os"><img src="https://img.shields.io/badge/-os-red.svg" alt="cat-os-badge" /></a> <a href="https://crates.io/categories/text-processing"><img src="https://img.shields.io/badge/-text_processing-red.svg" alt="cat-text-processing-badge" /></a> </td></tr>
<tr><td> <a href="basics.html#ex-lazy-constant">Declare lazily evaluated constant</a> </td><td> <a href="https://docs.rs/lazy_static/"><img src="https://img.shields.io/crates/v/lazy_static.svg?label=lazy_static" alt="lazy_static-badge" /></a> </td><td> <a href="https://crates.io/categories/caching"><img src="https://img.shields.io/badge/-caching-red.svg" alt="cat-caching-badge" /></a> <a href="https://crates.io/categories/rust-patterns"><img src="https://img.shields.io/badge/-rust_patterns-red.svg" alt="cat-rust-patterns-badge" /></a> </td></tr>
<tr><td> <a href="basics.html#ex-global-mut-state">Maintain global mutable state</a> </td><td> <a href="https://docs.rs/lazy_static/"><img src="https://img.shields.io/crates/v/lazy_static.svg?label=lazy_static" alt="lazy_static-badge" /></a> </td><td> <a href="https://crates.io/categories/rust-patterns"><img src="https://img.shields.io/badge/-rust_patterns-red.svg" alt="cat-rust-patterns-badge" /></a> </td></tr>
</tbody></table>
<a class="header" href="print.html#a-hrefencodinghtmlencodinga" id="a-hrefencodinghtmlencodinga"><h2><a href="encoding.html">Encoding</a></h2></a>
<table><thead><tr><th> Recipe </th><th> Crates </th><th> Categories </th></tr></thead><tbody>
<tr><td> <a href="encoding.html#ex-json-value">Serialize and deserialize unstructured JSON</a> </td><td> <a href="https://docs.serde.rs/serde_json/"><img src="https://img.shields.io/crates/v/serde_json.svg?label=serde_json" alt="serde-json-badge" /></a> </td><td> <a href="https://crates.io/categories/encoding"><img src="https://img.shields.io/badge/-encoding-red.svg" alt="cat-encoding-badge" /></a> </td></tr>
<tr><td> <a href="encoding.html#ex-toml-config">Deserialize a TOML configuration file</a> </td><td> <a href="https://docs.rs/toml/"><img src="https://img.shields.io/crates/v/toml.svg?label=toml" alt="toml-badge" /></a> </td><td> <a href="https://crates.io/categories/encoding"><img src="https://img.shields.io/badge/-encoding-red.svg" alt="cat-encoding-badge" /></a> </td></tr>
<tr><td> <a href="encoding.html#ex-percent-encode">Percent-encode a string</a> </td><td> <a href="https://docs.rs/url/"><img src="https://img.shields.io/crates/v/url.svg?label=url" alt="url-badge" /></a> </td><td> <a href="https://crates.io/categories/encoding"><img src="https://img.shields.io/badge/-encoding-red.svg" alt="cat-encoding-badge" /></a> </td></tr>
<tr><td> <a href="encoding.html#ex-urlencoded">Encode a string as application/x-www-form-urlencoded</a> </td><td> <a href="https://docs.rs/url/"><img src="https://img.shields.io/crates/v/url.svg?label=url" alt="url-badge" /></a> </td><td> <a href="https://crates.io/categories/encoding"><img src="https://img.shields.io/badge/-encoding-red.svg" alt="cat-encoding-badge" /></a> </td></tr>
<tr><td> <a href="encoding.html#ex-base64">Encode and decode base64</a> </td><td> <a href="https://docs.rs/base64/"><img src="https://img.shields.io/crates/v/base64.svg?label=base64" alt="base64-badge" /></a> </td><td> <a href="https://crates.io/categories/encoding"><img src="https://img.shields.io/badge/-encoding-red.svg" alt="cat-encoding-badge" /></a> </td></tr>
</tbody></table>
<a class="header" href="print.html#a-hrefconcurrencyhtmlconcurrencya" id="a-hrefconcurrencyhtmlconcurrencya"><h2><a href="concurrency.html">Concurrency</a></h2></a>
<table><thead><tr><th> Recipe </th><th> Crates </th><th> Categories </th></tr></thead><tbody>
<tr><td> <a href="concurrency.html#ex-rayon-iter-mut">Mutate the elements of an array in parallel</a> </td><td> <a href="https://docs.rs/rayon/"><img src="https://img.shields.io/crates/v/rayon.svg?label=rayon" alt="rayon-badge" /></a> </td><td> <a href="https://crates.io/categories/concurrency"><img src="https://img.shields.io/badge/-concurrency-red.svg" alt="cat-concurrency-badge" /></a> </td></tr>
</tbody></table>
<a class="header" href="print.html#a-hrefnethtmlnetworkinga" id="a-hrefnethtmlnetworkinga"><h2><a href="net.html">Networking</a></h2></a>
<table><thead><tr><th> Recipe </th><th> Crates </th><th> Categories </th></tr></thead><tbody>
<tr><td> <a href="net.html#ex-url-parse">Parse a URL from a string to a <code>Url</code> type</a> </td><td> <a href="https://docs.rs/url/"><img src="https://img.shields.io/crates/v/url.svg?label=url" alt="url-badge" /></a> </td><td> <a href="https://crates.io/categories/network-programming"><img src="https://img.shields.io/badge/-net-red.svg" alt="cat-net-badge" /></a> </td></tr>
<tr><td> <a href="net.html#ex-url-base">Create a base URL by removing path segments</a> </td><td> <a href="https://docs.rs/url/"><img src="https://img.shields.io/crates/v/url.svg?label=url" alt="url-badge" /></a> </td><td> <a href="https://crates.io/categories/network-programming"><img src="https://img.shields.io/badge/-net-red.svg" alt="cat-net-badge" /></a> </td></tr>
<tr><td> <a href="net.html#ex-url-new-from-base">Create new URLs from a base URL</a> </td><td> <a href="https://docs.rs/url/"><img src="https://img.shields.io/crates/v/url.svg?label=url" alt="url-badge" /></a> </td><td> <a href="https://crates.io/categories/network-programming"><img src="https://img.shields.io/badge/-net-red.svg" alt="cat-net-badge" /></a> </td></tr>
<tr><td> <a href="net.html#ex-url-origin">Extract the URL origin (scheme / host / port)</a> </td><td> <a href="https://docs.rs/url/"><img src="https://img.shields.io/crates/v/url.svg?label=url" alt="url-badge" /></a> </td><td> <a href="https://crates.io/categories/network-programming"><img src="https://img.shields.io/badge/-net-red.svg" alt="cat-net-badge" /></a> </td></tr>
<tr><td> <a href="net.html#ex-url-rm-frag">Remove fragment identifiers and query pairs from a URL</a> </td><td> <a href="https://docs.rs/url/"><img src="https://img.shields.io/crates/v/url.svg?label=url" alt="url-badge" /></a> </td><td> <a href="https://crates.io/categories/network-programming"><img src="https://img.shields.io/badge/-net-red.svg" alt="cat-net-badge" /></a> </td></tr>
<tr><td> <a href="net.html#ex-url-basic">Make a HTTP GET request after parsing a URL</a> </td><td> <a href="https://docs.rs/reqwest/"><img src="https://img.shields.io/crates/v/reqwest.svg?label=reqwest" alt="reqwest-badge" /></a> </td><td> <a href="https://crates.io/categories/network-programming"><img src="https://img.shields.io/badge/-net-red.svg" alt="cat-net-badge" /></a> </td></tr>
<tr><td> <a href="net.html#ex-url-download">Download a file to a temporary directory</a> </td><td> <a href="https://docs.rs/reqwest/"><img src="https://img.shields.io/crates/v/reqwest.svg?label=reqwest" alt="reqwest-badge" /></a> <a href="https://docs.rs/tempdir/"><img src="https://img.shields.io/crates/v/tempdir.svg?label=tempdir" alt="tempdir-badge" /></a> </td><td> <a href="https://crates.io/categories/network-programming"><img src="https://img.shields.io/badge/-net-red.svg" alt="cat-net-badge" /></a> <a href="https://crates.io/categories/filesystem"><img src="https://img.shields.io/badge/-filesystem-red.svg" alt="cat-filesystem-badge" /></a> </td></tr>
<tr><td> <a href="net.html#ex-rest-get">Query the GitHub API</a> </td><td> <a href="https://docs.rs/reqwest/"><img src="https://img.shields.io/crates/v/reqwest.svg?label=reqwest" alt="reqwest-badge" /></a> <a href="https://docs.rs/serde/"><img src="https://img.shields.io/crates/v/serde.svg?label=serde" alt="serde-badge" /></a> </td><td> <a href="https://crates.io/categories/network-programming"><img src="https://img.shields.io/badge/-net-red.svg" alt="cat-net-badge" /></a> <a href="https://crates.io/categories/encoding"><img src="https://img.shields.io/badge/-encoding-red.svg" alt="cat-encoding-badge" /></a> </td></tr>
<tr><td> <a href="net.html#ex-rest-head">Check if an API Resource Exists</a> </td><td> <a href="https://docs.rs/reqwest/"><img src="https://img.shields.io/crates/v/reqwest.svg?label=reqwest" alt="reqwest-badge" /></a> </td><td> <a href="https://crates.io/categories/network-programming"><img src="https://img.shields.io/badge/-net-red.svg" alt="cat-net-badge" /></a> </td></tr>
<tr><td> <a href="net.html#ex-rest-post">Create and delete Gist with GitHub API</a> </td><td> <a href="https://docs.rs/reqwest/"><img src="https://img.shields.io/crates/v/reqwest.svg?label=reqwest" alt="reqwest-badge" /></a> <a href="https://docs.rs/serde/"><img src="https://img.shields.io/crates/v/serde.svg?label=serde" alt="serde-badge" /></a> </td><td> <a href="https://crates.io/categories/network-programming"><img src="https://img.shields.io/badge/-net-red.svg" alt="cat-net-badge" /></a> <a href="https://crates.io/categories/encoding"><img src="https://img.shields.io/badge/-encoding-red.svg" alt="cat-encoding-badge" /></a> </td></tr>
<tr><td> <a href="net.html#ex-random-port-tcp">Listen on Unused port TCP/IP</a> </td><td> <a href="https://doc.rust-lang.org/std"><img src="https://img.shields.io/badge/std-1.17.0-blue.svg" alt="std-badge" /></a> </td><td> <a href="https://crates.io/categories/network-programming"><img src="https://img.shields.io/badge/-net-red.svg" alt="cat-net-badge" /></a> </td></tr>
</tbody></table>
<a class="header" href="print.html#a-hrefapphtmlapplication-developmenta" id="a-hrefapphtmlapplication-developmenta"><h2><a href="app.html">Application development</a></h2></a>
<table><thead><tr><th> Recipe </th><th> Crates </th><th> Categories </th></tr></thead><tbody>
<tr><td> <a href="app.html#ex-clap-basic">Parse command line arguments</a> </td><td> <a href="https://docs.rs/clap/"><img src="https://img.shields.io/crates/v/clap.svg?label=clap" alt="clap-badge" /></a> </td><td> <a href="https://crates.io/categories/command-line-interface"><img src="https://img.shields.io/badge/-command_line-red.svg" alt="cat-command-line-badge" /></a> </td></tr>
<tr><td> <a href="app.html#ex-log-debug">Log a debug message to the console</a> </td><td> <a href="https://docs.rs/log/"><img src="https://img.shields.io/crates/v/log.svg?label=log" alt="log-badge" /></a> <a href="https://docs.rs/env_logger/"><img src="https://img.shields.io/crates/v/env_logger.svg?label=env_logger" alt="env_logger-badge" /></a> </td><td> <a href="https://crates.io/categories/debugging"><img src="https://img.shields.io/badge/-debugging-red.svg" alt="cat-debugging-badge" /></a> </td></tr>
<tr><td> <a href="app.html#ex-log-error">Log an error message to the console</a> </td><td> <a href="https://docs.rs/log/"><img src="https://img.shields.io/crates/v/log.svg?label=log" alt="log-badge" /></a> <a href="https://docs.rs/env_logger/"><img src="https://img.shields.io/crates/v/env_logger.svg?label=env_logger" alt="env_logger-badge" /></a> </td><td> <a href="https://crates.io/categories/debugging"><img src="https://img.shields.io/badge/-debugging-red.svg" alt="cat-debugging-badge" /></a> </td></tr>
<tr><td> <a href="app.html#ex-log-mod">Enable log levels per module</a> </td><td> <a href="https://docs.rs/log/"><img src="https://img.shields.io/crates/v/log.svg?label=log" alt="log-badge" /></a> <a href="https://docs.rs/env_logger/"><img src="https://img.shields.io/crates/v/env_logger.svg?label=env_logger" alt="env_logger-badge" /></a> </td><td> <a href="https://crates.io/categories/debugging"><img src="https://img.shields.io/badge/-debugging-red.svg" alt="cat-debugging-badge" /></a> </td></tr>
<tr><td> <a href="app.html#ex-log-custom-logger">Log messages with a custom logger</a> </td><td> <a href="https://docs.rs/log/"><img src="https://img.shields.io/crates/v/log.svg?label=log" alt="log-badge" /></a> </td><td> <a href="https://crates.io/categories/debugging"><img src="https://img.shields.io/badge/-debugging-red.svg" alt="cat-debugging-badge" /></a> </td></tr>
<tr><td> <a href="app.html#ex-log-syslog">Log to the Unix syslog</a> </td><td> <a href="https://docs.rs/log/"><img src="https://img.shields.io/crates/v/log.svg?label=log" alt="log-badge" /></a> <a href="https://docs.rs/syslog/"><img src="https://img.shields.io/crates/v/syslog.svg?label=syslog" alt="syslog-badge" /></a> </td><td> <a href="https://crates.io/categories/debugging"><img src="https://img.shields.io/badge/-debugging-red.svg" alt="cat-debugging-badge" /></a> </td></tr>
<tr><td> <a href="app.html#ex-log-custom">Log messages to a custom location</a> </td><td> <a href="https://docs.rs/log/"><img src="https://img.shields.io/crates/v/log.svg?label=log" alt="log-badge" /></a> </td><td> <a href="https://crates.io/categories/debugging"><img src="https://img.shields.io/badge/-debugging-red.svg" alt="cat-debugging-badge" /></a> </td></tr>
<tr><td> <a href="app.html#ex-tar-temp">Unzip a tarball to a temporary directory</a> </td><td> <a href="https://docs.rs/flate2/"><img src="https://img.shields.io/crates/v/flate2.svg?label=flate2" alt="flate2-badge" /></a> <a href="https://docs.rs/tar/"><img src="https://img.shields.io/crates/v/tar.svg?label=tar" alt="tar-badge" /></a> <a href="https://docs.rs/tempdir/"><img src="https://img.shields.io/crates/v/tempdir.svg?label=tempdir" alt="tempdir-badge" /></a> </td><td> <a href="https://crates.io/categories/filesystem"><img src="https://img.shields.io/badge/-filesystem-red.svg" alt="cat-filesystem-badge" /></a> <a href="https://crates.io/categories/compression"><img src="https://img.shields.io/badge/-compression-red.svg" alt="cat-compression-badge" /></a> </td></tr>
<tr><td> <a href="app.html#ex-dedup-filenames">Recursively find duplicate file names</a> </td><td> <a href="https://docs.rs/walkdir/"><img src="https://img.shields.io/crates/v/walkdir.svg?label=walkdir" alt="walkdir-badge" /></a> </td><td> <a href="https://crates.io/categories/filesystem"><img src="https://img.shields.io/badge/-filesystem-red.svg" alt="cat-filesystem-badge" /></a> </td></tr>
<tr><td> <a href="app.html#ex-file-predicate">Recursively find all files with given predicate</a> </td><td> <a href="https://docs.rs/walkdir/"><img src="https://img.shields.io/crates/v/walkdir.svg?label=walkdir" alt="walkdir-badge" /></a> </td><td> <a href="https://crates.io/categories/filesystem"><img src="https://img.shields.io/badge/-filesystem-red.svg" alt="cat-filesystem-badge" /></a> </td></tr>
</tbody></table>
<!--
<p>Links, in a few categories. Follow the existing structure.</p>
<p>Individual pages contain a subset of these exact links, depending on
the crates and categories of their examples.</p>
<p>Keep lines sorted.</p>
<p>--&gt;</p>
<!-- Categories -->
<!-- Crates -->
<!-- Examples -->
<a class="header" href="print.html#about-cookin-with-rust" id="about-cookin-with-rust"><h1>About &quot;Cookin' with Rust&quot;</h1></a>
<a class="header" href="print.html#table-of-contents" id="table-of-contents"><h2>Table of contents</h2></a>
<ul>
<li><a href="print.html#who-this-book-is-for">Who this book is for</a></li>
<li><a href="print.html#how-to-read-this-book">How to read this book</a></li>
<li><a href="print.html#how-to-use-the-examples">How to use the examples</a></li>
<li><a href="print.html#a-note-about-error-handling">A note about error handling</a></li>
<li><a href="print.html#a-note-about-crate-representation">A note about crate representation</a></li>
</ul>
<a class="header" href="print.html#who-this-book-is-for" id="who-this-book-is-for"><h2>Who this book is for</h2></a>
<a class="header" href="print.html#how-to-read-this-book" id="how-to-read-this-book"><h2>How to read this book</h2></a>
<a class="header" href="print.html#how-to-use-the-examples" id="how-to-use-the-examples"><h2>How to use the examples</h2></a>
<a class="header" href="print.html#a-note-about-error-handling" id="a-note-about-error-handling"><h2>A note about error handling</h2></a>
<p>Error handling in Rust is robust when done correctly, but in today's
Rust it requires a fair bit of boilerplate. Because of this one often
sees Rust examples filled with <code>unwrap</code> calls instead of proper error
handling.</p>
<p>Since these recipes are intended to be reused as-is and encourage best
practices, they set up error handling correctly when there are
<code>Result</code> types involved.</p>
<p>The basic pattern we use is to have a <code>fn run() -&gt; Result</code> that acts
like the &quot;real&quot; main function. We use the <a href="https://docs.rs/error-chain/">error-chain</a> crate to make
<code>?</code> work within <code>run</code>.</p>
<p>The structure generally looks like:</p>
<pre><pre class="playpen"><code class="language-rust">#[macro_use]
extern crate error_chain;

use std::net::IpAddr;
use std::str;

error_chain! {
    foreign_links {
        Utf8(std::str::Utf8Error);
        AddrParse(std::net::AddrParseError);
    }
}

fn run() -&gt; Result&lt;()&gt; {
    let bytes = b&quot;2001:db8::1&quot;;

    // Bytes to string.
    let s = str::from_utf8(bytes)?;

    // String to IP address.
    let addr: IpAddr = s.parse()?;

    println!(&quot;{:?}&quot;, addr);
    Ok(())
}

quick_main!(run);
</code></pre></pre>
<p>This is using the <code>error_chain!</code> macro to define a custom <code>Error</code> and
<code>Result</code> type, along with automatic conversions from two standard
library error types. The automatic conversions make the <code>?</code> operator
work. The <code>quick_main!</code> macro generates the actual <code>main</code> function and
prints out the error if one occurred.</p>
<p>For more background on error handling in Rust, read <a href="https://doc.rust-lang.org/book/error-handling.html">this page of the
Rust book</a> and <a href="https://brson.github.io/2016/11/30/starting-with-error-chain">this blog post</a>.</p>
<a class="header" href="print.html#a-note-about-crate-representation" id="a-note-about-crate-representation"><h2>A note about crate representation</h2></a>
<!-- Links-->
<a class="header" href="print.html#basics" id="basics"><h1>Basics</h1></a>
<table><thead><tr><th> Recipe </th><th> Crates </th><th> Categories </th></tr></thead><tbody>
<tr><td> <a href="print.html#ex-std-read-lines">Read lines of strings from a file</a> </td><td> <a href="https://doc.rust-lang.org/std"><img src="https://img.shields.io/badge/std-1.17.0-blue.svg" alt="std-badge" /></a> </td><td> <a href="https://crates.io/categories/filesystem"><img src="https://img.shields.io/badge/-filesystem-red.svg" alt="cat-filesystem-badge" /></a> </td></tr>
<tr><td> <a href="print.html#ex-byteorder-le">Read and write integers in little-endian byte order</a> </td><td> <a href="https://docs.rs/byteorder/"><img src="https://img.shields.io/crates/v/byteorder.svg?label=byteorder" alt="byteorder-badge" /></a> </td><td> <a href="https://crates.io/categories/encoding"><img src="https://img.shields.io/badge/-encoding-red.svg" alt="cat-encoding-badge" /></a> </td></tr>
<tr><td> <a href="print.html#ex-rand-float">Generate random floating point numbers</a> </td><td> <a href="https://docs.rs/rand/"><img src="https://img.shields.io/crates/v/rand.svg?label=rand" alt="rand-badge" /></a> </td><td> <a href="https://crates.io/categories/science"><img src="https://img.shields.io/badge/-rand-red.svg" alt="cat-science-badge" /></a> </td></tr>
<tr><td> <a href="print.html#ex-rand-range">Generate random numbers within a range</a> </td><td> <a href="https://docs.rs/rand/"><img src="https://img.shields.io/crates/v/rand.svg?label=rand" alt="rand-badge" /></a> </td><td> <a href="https://crates.io/categories/science"><img src="https://img.shields.io/badge/-rand-red.svg" alt="cat-science-badge" /></a> </td></tr>
<tr><td> <a href="print.html#ex-rand-dist">Generate random numbers with normal distribution</a> </td><td> <a href="https://docs.rs/rand/"><img src="https://img.shields.io/crates/v/rand.svg?label=rand" alt="rand-badge" /></a> </td><td> <a href="https://crates.io/categories/science"><img src="https://img.shields.io/badge/-rand-red.svg" alt="cat-science-badge" /></a> </td></tr>
<tr><td> <a href="print.html#ex-rand-custom">Generate random values of a custom type</a> </td><td> <a href="https://docs.rs/rand/"><img src="https://img.shields.io/crates/v/rand.svg?label=rand" alt="rand-badge" /></a> </td><td> <a href="https://crates.io/categories/science"><img src="https://img.shields.io/badge/-rand-red.svg" alt="cat-science-badge" /></a> </td></tr>
<tr><td> <a href="print.html#ex-parse-subprocess-output">Run an External Command and Process Stdout</a> </td><td> <a href="https://docs.rs/regex/"><img src="https://img.shields.io/crates/v/regex.svg?label=regex" alt="regex-badge" /></a> </td><td> <a href="https://crates.io/categories/os"><img src="https://img.shields.io/badge/-os-red.svg" alt="cat-os-badge" /></a> <a href="https://crates.io/categories/text-processing"><img src="https://img.shields.io/badge/-text_processing-red.svg" alt="cat-text-processing-badge" /></a> </td></tr>
<tr><td> <a href="print.html#ex-lazy-constant">Declare lazily evaluated constant</a> </td><td> <a href="https://docs.rs/lazy_static/"><img src="https://img.shields.io/crates/v/lazy_static.svg?label=lazy_static" alt="lazy_static-badge" /></a> </td><td> <a href="https://crates.io/categories/caching"><img src="https://img.shields.io/badge/-caching-red.svg" alt="cat-caching-badge" /></a> <a href="https://crates.io/categories/rust-patterns"><img src="https://img.shields.io/badge/-rust_patterns-red.svg" alt="cat-rust-patterns-badge" /></a> </td></tr>
<tr><td> <a href="print.html#ex-global-mut-state">Maintain global mutable state</a> </td><td> <a href="https://docs.rs/lazy_static/"><img src="https://img.shields.io/crates/v/lazy_static.svg?label=lazy_static" alt="lazy_static-badge" /></a> </td><td> <a href="https://crates.io/categories/rust-patterns"><img src="https://img.shields.io/badge/-rust_patterns-red.svg" alt="cat-rust-patterns-badge" /></a> </td></tr>
</tbody></table>
<p><a name="ex-std-read-lines"></a></p>
<a class="header" href="print.html#read-lines-of-strings-from-a-file" id="read-lines-of-strings-from-a-file"><h2>Read lines of strings from a file</h2></a>
<p><a href="https://doc.rust-lang.org/std"><img src="https://img.shields.io/badge/std-1.17.0-blue.svg" alt="std-badge" /></a> <a href="https://crates.io/categories/filesystem"><img src="https://img.shields.io/badge/-filesystem-red.svg" alt="cat-filesystem-badge" /></a></p>
<p>Writes a three-line message to a file, then reads it back a line at a
time with the <a href="https://doc.rust-lang.org/std/io/struct.Lines.html"><code>Lines</code></a> iterator created by
<a href="https://doc.rust-lang.org/std/io/trait.BufRead.html#method.lines"><code>BufRead::lines</code></a>. <a href="https://doc.rust-lang.org/std/io/trait.BufRead.html"><code>BufRead</code></a> is a trait, and the most common way to
get one is from a <a href="https://doc.rust-lang.org/std/io/struct.BufReader.html"><code>BufReader</code></a>, which is constructed from some type
that implements <a href="https://doc.rust-lang.org/std/io/trait.Write.html"><code>Write</code></a>, here a <a href="https://doc.rust-lang.org/std/fs/struct.File.html"><code>File</code></a>. The <a href="https://doc.rust-lang.org/std/fs/struct.File.html"><code>File</code></a> is opened
for writing with <a href="https://doc.rust-lang.org/std/fs/struct.File.html#method.create"><code>File::create</code></a>, and reading with <a href="https://doc.rust-lang.org/std/fs/struct.File.html#method.open"><code>File::open</code></a>.</p>
<pre><pre class="playpen"><code class="language-rust"># #[macro_use]
# extern crate error_chain;
#
use std::fs::File;
use std::io::{Write, BufReader, BufRead};
#
# error_chain! {
#    foreign_links {
#        Io(std::io::Error);
#    }
# }

fn run() -&gt; Result&lt;()&gt; {
    let path = &quot;lines.txt&quot;;

    let mut output = File::create(path)?;
    write!(output, &quot;Rust\n💖\nFun&quot;)?;

    let input = File::open(path)?;
    let buffered = BufReader::new(input);

    for line in buffered.lines() {
        println!(&quot;{}&quot;, line?);
    }

    Ok(())
}
#
# quick_main!(run);
</code></pre></pre>
<p><a name="ex-byteorder-le"></a></p>
<a class="header" href="print.html#read-and-write-integers-in-little-endian-byte-order" id="read-and-write-integers-in-little-endian-byte-order"><h2>Read and write integers in little-endian byte order</h2></a>
<p><a href="https://docs.rs/byteorder/"><img src="https://img.shields.io/crates/v/byteorder.svg?label=byteorder" alt="byteorder-badge" /></a> <a href="https://crates.io/categories/encoding"><img src="https://img.shields.io/badge/-encoding-red.svg" alt="cat-encoding-badge" /></a></p>
<pre><pre class="playpen"><code class="language-rust"># #[macro_use]
# extern crate error_chain;
extern crate byteorder;

use byteorder::{LittleEndian, ReadBytesExt, WriteBytesExt};

#[derive(Default, PartialEq, Debug)]
struct Payload {
    kind: u8,
    value: u16,
}
#
# error_chain! {
#    foreign_links {
#        Io(std::io::Error);
#    }
# }

fn run() -&gt; Result&lt;()&gt; {
    let original_payload = Payload::default();
    let encoded_bytes = encode(&amp;original_payload)?;
    let decoded_payload = decode(&amp;encoded_bytes)?;
    assert_eq!(original_payload, decoded_payload);
    Ok(())
}

fn encode(payload: &amp;Payload) -&gt; Result&lt;Vec&lt;u8&gt;&gt; {
    let mut bytes = vec![];
    bytes.write_u8(payload.kind)?;
    bytes.write_u16::&lt;LittleEndian&gt;(payload.value)?;
    Ok(bytes)
}

fn decode(mut bytes: &amp;[u8]) -&gt; Result&lt;Payload&gt; {
    let payload = Payload {
        kind: bytes.read_u8()?,
        value: bytes.read_u16::&lt;LittleEndian&gt;()?,
    };
    Ok(payload)
}
#
# quick_main!(run);
</code></pre></pre>
<p><a name="ex-rand-float"></a></p>
<a class="header" href="print.html#generate-random-floating-point-numbers" id="generate-random-floating-point-numbers"><h2>Generate random floating point numbers</h2></a>
<p><a href="https://docs.rs/rand/"><img src="https://img.shields.io/crates/v/rand.svg?label=rand" alt="rand-badge" /></a> <a href="https://crates.io/categories/science"><img src="https://img.shields.io/badge/-rand-red.svg" alt="cat-science-badge" /></a></p>
<pre><pre class="playpen"><code class="language-rust">extern crate rand;
use rand::Rng;

fn main() {
    let mut rng = rand::thread_rng();
    println!(&quot;Random f64: {}&quot;, rng.gen::&lt;f64&gt;());
}
</code></pre></pre>
<p><a name="ex-rand-range"></a></p>
<a class="header" href="print.html#generate-random-numbers-within-a-range" id="generate-random-numbers-within-a-range"><h2>Generate random numbers within a range</h2></a>
<p><a href="https://docs.rs/rand/"><img src="https://img.shields.io/crates/v/rand.svg?label=rand" alt="rand-badge" /></a> <a href="https://crates.io/categories/science"><img src="https://img.shields.io/badge/-rand-red.svg" alt="cat-science-badge" /></a></p>
<p>A random value within a range <code>[0, 10)</code> (not including <code>10</code>) is generated with <a href="https://doc.rust-lang.org/rand/rand/trait.Rng.html#method.gen_range"><code>Rng::gen_range</code></a>.</p>
<pre><pre class="playpen"><code class="language-rust">extern crate rand;

use rand::Rng;

fn main() {
    let mut rng = rand::thread_rng();
    println!(&quot;{}&quot;, rng.gen_range(0, 10));
}
</code></pre></pre>
<p><a name="ex-rand-dist"></a></p>
<a class="header" href="print.html#generate-random-numbers-with-normal-distribution" id="generate-random-numbers-with-normal-distribution"><h2>Generate random numbers with normal distribution</h2></a>
<p><a href="https://docs.rs/rand/"><img src="https://img.shields.io/crates/v/rand.svg?label=rand" alt="rand-badge" /></a> <a href="https://crates.io/categories/science"><img src="https://img.shields.io/badge/-rand-red.svg" alt="cat-science-badge" /></a></p>
<p><a href="https://doc.rust-lang.org/rand/rand/distributions/normal/struct.Normal.html"><code>Normal</code></a> distribution with mean <code>3</code> and standard deviation <code>5</code>
is created. A random value is generated with <a href="https://doc.rust-lang.org/rand/rand/distributions/trait.IndependentSample.html#tymethod.ind_sample"><code>IndependentSample::ind_sample</code></a>.</p>
<pre><pre class="playpen"><code class="language-rust">extern crate rand;

use rand::distributions::{Normal, IndependentSample};

fn main() {
    let normal = Normal::new(3.0, 5.0);
    let mut rng = rand::thread_rng();
    let v = normal.ind_sample(&amp;mut rng);
    println!(&quot;{} is from a N(3, 25) distribution&quot;, v)
}
</code></pre></pre>
<p><a name="ex-rand-custom"></a></p>
<a class="header" href="print.html#generate-random-values-of-a-custom-type" id="generate-random-values-of-a-custom-type"><h2>Generate random values of a custom type</h2></a>
<p><a href="https://docs.rs/rand/"><img src="https://img.shields.io/crates/v/rand.svg?label=rand" alt="rand-badge" /></a> <a href="https://crates.io/categories/science"><img src="https://img.shields.io/badge/-rand-red.svg" alt="cat-science-badge" /></a></p>
<p>A tuple <code>(i32, bool, f64)</code> and variable of user defined type <code>Point</code>
are randomly generated. In order to allow random generation of <code>Point</code>
it needs to implement the <a href="https://doc.rust-lang.org/rand/rand/trait.Rand.html"><code>rand::Rand</code></a> trait.</p>
<pre><pre class="playpen"><code class="language-rust">extern crate rand;
use rand::{Rng, Rand};

#[derive(Debug)]
struct Point {
    x: i32,
    y: i32,
}

impl Rand for Point {
    fn rand&lt;R: Rng&gt;(rng: &amp;mut R) -&gt; Point {
        let (rand_x, rand_y) = rng.gen();
        Point { x: rand_x, y: rand_y }
    }
}

fn main() {
    let mut rng = rand::thread_rng();
    let rand_tuple = rng.gen::&lt;(i32, bool, f64)&gt;();
    let rand_point: Point = rng.gen();
    println!(&quot;Random tuple: {:?}&quot;, rand_tuple);
    println!(&quot;Random Point: {:?}&quot;, rand_point);
}
</code></pre></pre>
<p><a name="ex-parse-subprocess-output"></a></p>
<a class="header" href="print.html#run-an-external-command-and-process-stdout" id="run-an-external-command-and-process-stdout"><h2>Run an External Command and Process Stdout</h2></a>
<p><a href="https://docs.rs/regex/"><img src="https://img.shields.io/crates/v/regex.svg?label=regex" alt="regex-badge" /></a> <a href="https://crates.io/categories/os"><img src="https://img.shields.io/badge/-os-red.svg" alt="cat-os-badge" /></a> <a href="https://crates.io/categories/text-processing"><img src="https://img.shields.io/badge/-text_processing-red.svg" alt="cat-text-processing-badge" /></a></p>
<p><code>git log --oneline</code> is run as an external <a href="https://doc.rust-lang.org/std/process/struct.Command.html"><code>Command</code></a> and its <a href="https://doc.rust-lang.org/std/process/struct.Output.html"><code>Output</code></a> is
inspected using <a href="https://doc.rust-lang.org/regex/regex/struct.Regex.html"><code>Regex</code></a> to get the hash and message of the last 5 commits.</p>
<pre><pre class="playpen"><code class="language-rust"># #[macro_use]
# extern crate error_chain;
extern crate regex;

use std::process::Command;
use regex::Regex;
#
# error_chain!{
#    foreign_links {
#        Io(std::io::Error);
#        Regex(regex::Error);
#        Utf8(std::string::FromUtf8Error);
#    }
# }

#[derive(PartialEq, Default, Clone, Debug)]
struct Commit {
    hash: String,
    message: String,
}

fn run() -&gt; Result&lt;()&gt; {
    let output = Command::new(&quot;git&quot;).arg(&quot;log&quot;).arg(&quot;--oneline&quot;).output()?;

    if !output.status.success() {
        bail!(&quot;Command executed with failing error code&quot;);
    }

    let pattern = Regex::new(r&quot;(?x)
                               ([0-9a-fA-F]+) # commit hash
                               (.*)           # The commit message&quot;)?;

    let stdout = String::from_utf8(output.stdout)?;
    let commits = stdout
        .lines()
        .filter_map(|line| pattern.captures(line))
        .map(|cap| {
                 Commit {
                     hash: cap[1].to_string(),
                     message: cap[2].trim().to_string(),
                 }
             })
        .take(5);

    for commit in commits {
        println!(&quot;{:?}&quot;, commit);
    }

    Ok(())
}
#
# quick_main!(run);
</code></pre></pre>
<p><a name="ex-lazy-constant"></a></p>
<a class="header" href="print.html#declare-lazily-evaluated-constant" id="declare-lazily-evaluated-constant"><h2>Declare lazily evaluated constant</h2></a>
<p><a href="https://docs.rs/lazy_static/"><img src="https://img.shields.io/crates/v/lazy_static.svg?label=lazy_static" alt="lazy_static-badge" /></a> <a href="https://crates.io/categories/caching"><img src="https://img.shields.io/badge/-caching-red.svg" alt="cat-caching-badge" /></a> <a href="https://crates.io/categories/rust-patterns"><img src="https://img.shields.io/badge/-rust_patterns-red.svg" alt="cat-rust-patterns-badge" /></a></p>
<p>Declares a lazily evaluated constant <a href="https://doc.rust-lang.org/std/collections/struct.HashMap.html"><code>HashMap</code></a>. The <a href="https://doc.rust-lang.org/std/collections/struct.HashMap.html"><code>HashMap</code></a> will
be evaluated once and stored behind a global static reference.</p>
<pre><pre class="playpen"><code class="language-rust">#[macro_use]
extern crate lazy_static;

use std::collections::HashMap;

lazy_static! {
    static ref PRIVILEGES: HashMap&lt;&amp;'static str, Vec&lt;&amp;'static str&gt;&gt; = {
        let mut map = HashMap::new();
        map.insert(&quot;James&quot;, vec![&quot;user&quot;, &quot;admin&quot;]);
        map.insert(&quot;Jim&quot;, vec![&quot;user&quot;]);
        map
    };
}

fn show_access(name: &amp;str) {
    let access = PRIVILEGES.get(name);
    println!(&quot;{}: {:?}&quot;, name, access);
}

fn main() {
    let access = PRIVILEGES.get(&quot;James&quot;);
    println!(&quot;James: {:?}&quot;, access);

    show_access(&quot;Jim&quot;);
}
</code></pre></pre>
<p><a name="ex-global-mut-state"></a></p>
<a class="header" href="print.html#maintain-global-mutable-state" id="maintain-global-mutable-state"><h2>Maintain global mutable state</h2></a>
<p><a href="https://docs.rs/lazy_static/"><img src="https://img.shields.io/crates/v/lazy_static.svg?label=lazy_static" alt="lazy_static-badge" /></a> <a href="https://crates.io/categories/rust-patterns"><img src="https://img.shields.io/badge/-rust_patterns-red.svg" alt="cat-rust-patterns-badge" /></a></p>
<p>Declares some global state using <a href="https://docs.rs/lazy_static/">lazy_static</a>. Since <a href="https://docs.rs/lazy_static/">lazy_static</a>
creates a globally available <code>static ref</code> we also need to wrap our state
in a <a href="https://doc.rust-lang.org/std/sync/struct.Mutex.html"><code>Mutex</code></a> to allow mutation (also see <a href="https://doc.rust-lang.org/std/sync/struct.RwLock.html"><code>RwLock</code></a>). The <a href="https://doc.rust-lang.org/std/sync/struct.Mutex.html"><code>Mutex</code></a> ensures
the state cannot be simultaneously accessed by multiple threads, preventing
race conditions. A <a href="https://doc.rust-lang.org/std/sync/struct.MutexGuard.html"><code>MutexGuard</code></a> must be acquired to read or mutate the
value stored in a <a href="https://doc.rust-lang.org/std/sync/struct.Mutex.html"><code>Mutex</code></a>.</p>
<pre><pre class="playpen"><code class="language-rust"># #[macro_use]
# extern crate error_chain;
#[macro_use]
extern crate lazy_static;

use std::sync::Mutex;
#
# error_chain!{ }

lazy_static! {
    static ref FRUIT: Mutex&lt;Vec&lt;String&gt;&gt; = Mutex::new(Vec::new());
}

fn insert(fruit: &amp;str) -&gt; Result&lt;()&gt; {
    // acquire exclusive access
    let mut db = FRUIT.lock()
        .map_err(|_| &quot;Failed to acquire MutexGuard&quot;)?;
    db.push(fruit.to_string());
    Ok(())
    // release exclusive access
}

fn run() -&gt; Result&lt;()&gt; {
    insert(&quot;apple&quot;)?;
    insert(&quot;orange&quot;)?;
    insert(&quot;peach&quot;)?;
    {
        // acquire access
        let db = FRUIT.lock()
            .map_err(|_| &quot;Failed to acquire MutexGuard&quot;)?;

        for (i, item) in db.iter().enumerate() {
            println!(&quot;{}: {}&quot;, i, item);
        }
        // release access
    }
    insert(&quot;grape&quot;)?;
    Ok(())
}
#
# quick_main!(run);
</code></pre></pre>
<!-- Categories -->
<!-- Crates -->
<!-- API links -->
<a class="header" href="print.html#encoding" id="encoding"><h1>Encoding</h1></a>
<table><thead><tr><th> Recipe </th><th> Crates </th><th> Categories </th></tr></thead><tbody>
<tr><td> <a href="print.html#ex-json-value">Serialize and deserialize unstructured JSON</a> </td><td> <a href="https://docs.serde.rs/serde_json/"><img src="https://img.shields.io/crates/v/serde_json.svg?label=serde_json" alt="serde-json-badge" /></a> </td><td> <a href="https://crates.io/categories/encoding"><img src="https://img.shields.io/badge/-encoding-red.svg" alt="cat-encoding-badge" /></a> </td></tr>
<tr><td> <a href="print.html#ex-toml-config">Deserialize a TOML configuration file</a> </td><td> <a href="https://docs.rs/toml/"><img src="https://img.shields.io/crates/v/toml.svg?label=toml" alt="toml-badge" /></a> </td><td> <a href="https://crates.io/categories/encoding"><img src="https://img.shields.io/badge/-encoding-red.svg" alt="cat-encoding-badge" /></a> </td></tr>
<tr><td> <a href="print.html#ex-percent-encode">Percent-encode a string</a> </td><td> <a href="https://docs.rs/url/"><img src="https://img.shields.io/crates/v/url.svg?label=url" alt="url-badge" /></a> </td><td> <a href="https://crates.io/categories/encoding"><img src="https://img.shields.io/badge/-encoding-red.svg" alt="cat-encoding-badge" /></a> </td></tr>
<tr><td> <a href="print.html#ex-urlencoded">Encode a string as application/x-www-form-urlencoded</a> </td><td> <a href="https://docs.rs/url/"><img src="https://img.shields.io/crates/v/url.svg?label=url" alt="url-badge" /></a> </td><td> <a href="https://crates.io/categories/encoding"><img src="https://img.shields.io/badge/-encoding-red.svg" alt="cat-encoding-badge" /></a> </td></tr>
<tr><td> <a href="print.html#ex-hex-encode-decode">Encode and decode hex</a> </td><td> <a href="https://github.com/ia0/data-encoding"><img src="https://img.shields.io/crates/v/data-encoding.svg?label=url" alt="data-encoding-badge" /></a> </td><td> <a href="https://crates.io/categories/encoding"><img src="https://img.shields.io/badge/-encoding-red.svg" alt="cat-encoding-badge" /></a> </td></tr>
<tr><td> <a href="print.html#ex-base64">Encode and decode base64</a> </td><td> <a href="https://docs.rs/base64/"><img src="https://img.shields.io/crates/v/base64.svg?label=base64" alt="base64-badge" /></a> </td><td> <a href="https://crates.io/categories/encoding"><img src="https://img.shields.io/badge/-encoding-red.svg" alt="cat-encoding-badge" /></a> </td></tr>
</tbody></table>
<p><a name="ex-json-value"></a></p>
<a class="header" href="print.html#serialize-and-deserialize-unstructured-json" id="serialize-and-deserialize-unstructured-json"><h2>Serialize and deserialize unstructured JSON</h2></a>
<p><a href="https://docs.serde.rs/serde_json/"><img src="https://img.shields.io/crates/v/serde_json.svg?label=serde_json" alt="serde-json-badge" /></a> <a href="https://crates.io/categories/encoding"><img src="https://img.shields.io/badge/-encoding-red.svg" alt="cat-encoding-badge" /></a></p>
<p>The <a href="https://docs.serde.rs/serde_json/"><code>serde_json</code></a> crate provides a <a href="https://docs.serde.rs/serde_json/fn.from_str.html"><code>from_str</code></a> function to parse a <code>&amp;str</code> of
JSON into a type of the caller's choice.</p>
<p>Unstructured JSON can be parsed into a universal <a href="https://docs.serde.rs/serde_json/enum.Value.html"><code>serde_json::Value</code></a> type that
is able to represent any valid JSON data.</p>
<p>The example below shows a <code>&amp;str</code> of JSON being parsed and then compared to what
we expect the parsed value to be. The expected value is declared using the
<a href="https://docs.serde.rs/serde_json/macro.json.html"><code>json!</code></a> macro.</p>
<pre><pre class="playpen"><code class="language-rust"># #[macro_use]
# extern crate error_chain;
#[macro_use]
extern crate serde_json;

use serde_json::Value;
#
# error_chain! {
#    foreign_links {
#        Json(serde_json::Error);
#    }
# }

fn run() -&gt; Result&lt;()&gt; {
    let j = r#&quot;{
                 &quot;userid&quot;: 103609,
                 &quot;verified&quot;: true,
                 &quot;access_privileges&quot;: [
                   &quot;user&quot;,
                   &quot;admin&quot;
                 ]
               }&quot;#;

    let parsed: Value = serde_json::from_str(j)?;

    let expected = json!({
        &quot;userid&quot;: 103609,
        &quot;verified&quot;: true,
        &quot;access_privileges&quot;: [
            &quot;user&quot;,
            &quot;admin&quot;
        ]
    });

    assert_eq!(parsed, expected);

    Ok(())
}
#
# quick_main!(run);
</code></pre></pre>
<p><a name="ex-toml-config"></a></p>
<a class="header" href="print.html#deserialize-a-toml-configuration-file" id="deserialize-a-toml-configuration-file"><h2>Deserialize a TOML configuration file</h2></a>
<p><a href="https://docs.rs/toml/"><img src="https://img.shields.io/crates/v/toml.svg?label=toml" alt="toml-badge" /></a> <a href="https://crates.io/categories/encoding"><img src="https://img.shields.io/badge/-encoding-red.svg" alt="cat-encoding-badge" /></a></p>
<p>Parse some TOML into a universal <code>toml::Value</code> that is able to represent any
valid TOML data.</p>
<pre><pre class="playpen"><code class="language-rust"># #[macro_use]
# extern crate error_chain;
extern crate toml;

use toml::Value;
#
# error_chain! {
#    foreign_links {
#        Toml(toml::de::Error);
#    }
# }

fn run() -&gt; Result&lt;()&gt; {
    let toml_content = r#&quot;
          [package]
          name = &quot;your_package&quot;
          version = &quot;0.1.0&quot;
          authors = [&quot;You! &lt;you@example.org&gt;&quot;]

          [dependencies]
          serde = &quot;1.0&quot;
          &quot;#;

    let package_info: Value = toml::from_str(toml_content)?;

    assert_eq!(package_info[&quot;dependencies&quot;][&quot;serde&quot;].as_str(), Some(&quot;1.0&quot;));
    assert_eq!(package_info[&quot;package&quot;][&quot;name&quot;].as_str(), Some(&quot;your_package&quot;));

    Ok(())
}
#
# quick_main!(run);
</code></pre></pre>
<p>Parse TOML into your own structs using Serde:</p>
<p><a href="https://docs.serde.rs/serde_json/"><img src="https://img.shields.io/crates/v/serde_json.svg?label=serde_json" alt="serde-json-badge" /></a> <a href="https://docs.rs/toml/"><img src="https://img.shields.io/crates/v/toml.svg?label=toml" alt="toml-badge" /></a> <a href="https://crates.io/categories/encoding"><img src="https://img.shields.io/badge/-encoding-red.svg" alt="cat-encoding-badge" /></a></p>
<pre><pre class="playpen"><code class="language-rust"># #[macro_use]
# extern crate error_chain;
#[macro_use]
extern crate serde_derive;
extern crate serde;
extern crate toml;

use std::collections::HashMap;

#[derive(Deserialize)]
struct Config {
    package: Package,
    dependencies: HashMap&lt;String, String&gt;,
}

#[derive(Deserialize)]
struct Package {
    name: String,
    version: String,
    authors: Vec&lt;String&gt;,
}
#
# error_chain! {
#    foreign_links {
#        Toml(toml::de::Error);
#    }
# }

fn run() -&gt; Result&lt;()&gt; {
    let toml_content = r#&quot;
          [package]
          name = &quot;your_package&quot;
          version = &quot;0.1.0&quot;
          authors = [&quot;You! &lt;you@example.org&gt;&quot;]

          [dependencies]
          serde = &quot;1.0&quot;
          &quot;#;

    let package_info: Config = toml::from_str(toml_content)?;

    assert_eq!(package_info.package.name, &quot;your_package&quot;);
    assert_eq!(package_info.package.version, &quot;0.1.0&quot;);
    assert_eq!(package_info.package.authors, vec![&quot;You! &lt;you@example.org&gt;&quot;]);
    assert_eq!(package_info.dependencies[&quot;serde&quot;], &quot;1.0&quot;);

    Ok(())
}
#
# quick_main!(run);
</code></pre></pre>
<p><a name="ex-percent-encode"></a></p>
<a class="header" href="print.html#percent-encode-a-string" id="percent-encode-a-string"><h2>Percent-encode a string</h2></a>
<p><a href="https://docs.rs/url/"><img src="https://img.shields.io/crates/v/url.svg?label=url" alt="url-badge" /></a> <a href="https://crates.io/categories/encoding"><img src="https://img.shields.io/badge/-encoding-red.svg" alt="cat-encoding-badge" /></a></p>
<p>Encode an input string with <a href="https://en.wikipedia.org/wiki/Percent-encoding">percent-encoding</a> using the <a href="https://docs.rs/url/1.*/url/percent_encoding/fn.utf8_percent_encode.html"><code>utf8_percent_encode</code></a>
function from the <code>url</code> crate. Then decode using the <a href="https://docs.rs/url/1.*/url/percent_encoding/fn.percent_decode.html"><code>percent_decode</code></a>
function.</p>
<pre><pre class="playpen"><code class="language-rust"># #[macro_use]
# extern crate error_chain;
extern crate url;

use url::percent_encoding::{utf8_percent_encode, percent_decode, DEFAULT_ENCODE_SET};
#
# error_chain! {
#    foreign_links {
#        Utf8(std::str::Utf8Error);
#    }
# }

fn run() -&gt; Result&lt;()&gt; {
    let input = &quot;confident, productive systems programming&quot;;

    let iter = utf8_percent_encode(input, DEFAULT_ENCODE_SET);
    let encoded: String = iter.collect();
    assert_eq!(encoded, &quot;confident,%20productive%20systems%20programming&quot;);

    let iter = percent_decode(encoded.as_bytes());
    let decoded = iter.decode_utf8()?;
    assert_eq!(decoded, &quot;confident, productive systems programming&quot;);

    Ok(())
}
#
# quick_main!(run);
</code></pre></pre>
<p>The encode set defines which bytes (in addition to non-ASCII and controls) need
to be percent-encoded. The choice of this set depends on context. For example,
<code>?</code> needs to be encoded in a URL path but not in a query string.</p>
<p>The return value of encoding is an iterator of <code>&amp;str</code> slices which can be
collected into a <code>String</code>.</p>
<p><a name="ex-urlencoded"></a></p>
<a class="header" href="print.html#encode-a-string-as-applicationx-www-form-urlencoded" id="encode-a-string-as-applicationx-www-form-urlencoded"><h2>Encode a string as application/x-www-form-urlencoded</h2></a>
<p><a href="https://docs.rs/url/"><img src="https://img.shields.io/crates/v/url.svg?label=url" alt="url-badge" /></a> <a href="https://crates.io/categories/encoding"><img src="https://img.shields.io/badge/-encoding-red.svg" alt="cat-encoding-badge" /></a></p>
<p>A string is encoded into <a href="https://url.spec.whatwg.org/#application/x-www-form-urlencoded">application/x-www-form-urlencoded</a> syntax
using the <a href="https://docs.rs/url/1.4.0/url/form_urlencoded/fn.byte_serialize.html"><code>form_urlencoded::byte_serialize</code></a> and subsequently
decoded with <a href="https://docs.rs/url/*/url/form_urlencoded/fn.parse.html"><code>form_urlencoded::parse</code></a>. Both functions return iterators
that can be collected into a <code>String</code>.</p>
<pre><pre class="playpen"><code class="language-rust">extern crate url;
use url::form_urlencoded::{byte_serialize, parse};

fn main() {
    let urlencoded: String = byte_serialize(&quot;What is ❤?&quot;.as_bytes()).collect();
    assert_eq!(urlencoded, &quot;What+is+%E2%9D%A4%3F&quot;);
    println!(&quot;urlencoded:'{}'&quot;, urlencoded);

    let decoded: String = parse(urlencoded.as_bytes())
        .map(|(key, val)| [key, val].concat())
        .collect();
    assert_eq!(decoded, &quot;What is ❤?&quot;);
    println!(&quot;decoded:'{}'&quot;, decoded);
}
</code></pre></pre>
<p><a name="ex-hex-encode-decode"></a></p>
<a class="header" href="print.html#encode-and-decode-hex" id="encode-and-decode-hex"><h2>Encode and decode hex</h2></a>
<p><a href="https://github.com/ia0/data-encoding"><img src="https://img.shields.io/crates/v/data-encoding.svg?label=url" alt="data-encoding-badge" /></a> <a href="https://crates.io/categories/encoding"><img src="https://img.shields.io/badge/-encoding-red.svg" alt="cat-encoding-badge" /></a></p>
<p>The <a href="https://github.com/ia0/data-encoding"><code>data_encoding</code></a> crate provides a <code>HEXUPPER::encode</code> method which
takes a <code>&amp;[u8]</code> and returns a <code>String</code> containing the hexadecimal
representation of the data.</p>
<p>Similarly, a <code>HEXUPPER::decode</code> method is provided which takes a <code>&amp;[u8]</code> and
returns a <code>Vec&lt;u8&gt;</code> if the input data is successfully decoded.</p>
<p>The example below shows a <code>&amp;[u8]</code> of data being converted to its hexadecimal
representation and then being compared to its expected value. The returned
hex <code>String</code> is then converted back to its original representation and is
compared to the original value provided.</p>
<pre><pre class="playpen"><code class="language-rust"># #[macro_use]
# extern crate error_chain;
extern crate data_encoding;

use data_encoding::{HEXUPPER, DecodeError};
#
# error_chain! {
#    foreign_links {
#        Decode(DecodeError);
#    }
# }

fn run() -&gt; Result&lt;()&gt; {
    let original = b&quot;The quick brown fox jumps over the lazy dog.&quot;;
    let expected = &quot;54686520717569636B2062726F776E20666F78206A756D7073206F76\
        657220746865206C617A7920646F672E&quot;;

    let encoded = HEXUPPER.encode(original);
    assert_eq!(encoded, expected);

    let decoded = HEXUPPER.decode(&amp;encoded.into_bytes())?;
    assert_eq!(&amp;decoded[..], &amp;original[..]);

    Ok(())
}
#
# quick_main!(run);
</code></pre></pre>
<p><a name="ex-base64"></a></p>
<a class="header" href="print.html#encode-and-decode-base64" id="encode-and-decode-base64"><h2>Encode and decode base64</h2></a>
<p><a href="https://docs.rs/base64/"><img src="https://img.shields.io/crates/v/base64.svg?label=base64" alt="base64-badge" /></a> <a href="https://crates.io/categories/encoding"><img src="https://img.shields.io/badge/-encoding-red.svg" alt="cat-encoding-badge" /></a></p>
<p>Byte slice is encoded into <code>base64</code> String with help of <a href="https://docs.rs/base64/*/base64/fn.encode.html"><code>encode</code></a>
and subsequently decoded with <a href="https://docs.rs/base64/*/base64/fn.decode.html"><code>decode</code></a>.</p>
<pre><pre class="playpen"><code class="language-rust"># #[macro_use]
# extern crate error_chain;
extern crate base64;

use std::str;
use base64::{encode, decode};
#
# error_chain! {
#    foreign_links {
#        Base64(base64::DecodeError);
#        Utf8Error(str::Utf8Error);
#    }
# }

fn run() -&gt; Result&lt;()&gt; {
    let hello = b&quot;hello rustaceans&quot;;
    let encoded = encode(hello);
    let decoded = decode(&amp;encoded)?;

    println!(&quot;origin: {}&quot;, str::from_utf8(hello)?);
    println!(&quot;base64 encoded: {}&quot;, encoded);
    println!(&quot;back to origin: {}&quot;, str::from_utf8(&amp;decoded)?);

    Ok(())
}
#
# quick_main!(run);
</code></pre></pre>
<!-- Categories -->
<!-- Crates -->
<!-- Reference -->
<a class="header" href="print.html#concurrency" id="concurrency"><h1>Concurrency</h1></a>
<table><thead><tr><th> Recipe </th><th> Crates </th><th> Categories </th></tr></thead><tbody>
<tr><td> <a href="print.html#ex-rayon-iter-mut">Mutate the elements of an array in parallel</a> </td><td> <a href="https://docs.rs/rayon/"><img src="https://img.shields.io/crates/v/rayon.svg?label=rayon" alt="rayon-badge" /></a> </td><td> <a href="https://crates.io/categories/concurrency"><img src="https://img.shields.io/badge/-concurrency-red.svg" alt="cat-concurrency-badge" /></a> </td></tr>
</tbody></table>
<p><a name="ex-rayon-iter-mut"></a></p>
<a class="header" href="print.html#mutate-the-elements-of-an-array-in-parallel" id="mutate-the-elements-of-an-array-in-parallel"><h2>Mutate the elements of an array in parallel</h2></a>
<p><a href="https://docs.rs/rayon/"><img src="https://img.shields.io/crates/v/rayon.svg?label=rayon" alt="rayon-badge" /></a> <a href="https://crates.io/categories/concurrency"><img src="https://img.shields.io/badge/-concurrency-red.svg" alt="cat-concurrency-badge" /></a></p>
<pre><pre class="playpen"><code class="language-rust">extern crate rayon;

use rayon::prelude::*;

fn main() {
    let mut arr = [0, 7, 9, 11];

    arr.par_iter_mut().for_each(|p| *p -= 1);

    println!(&quot;{:?}&quot;, arr);
}
</code></pre></pre>
<p>The example uses the Rayon crate, which is a data parallelism library for Rust.
Rayon provides the <code>par_iter_mut()</code> method for any parallel iterable data type.
It lets us write iterator-like chains that execute in parallel.</p>
<!-- Categories -->
<!-- Crates -->
<a class="header" href="print.html#networking" id="networking"><h1>Networking</h1></a>
<table><thead><tr><th> Recipe </th><th> Crates </th><th> Categories </th></tr></thead><tbody>
<tr><td> <a href="print.html#ex-url-parse">Parse a URL from a string to a <code>Url</code> type</a> </td><td> <a href="https://docs.rs/url/"><img src="https://img.shields.io/crates/v/url.svg?label=url" alt="url-badge" /></a> </td><td> <a href="https://crates.io/categories/network-programming"><img src="https://img.shields.io/badge/-net-red.svg" alt="cat-net-badge" /></a> </td></tr>
<tr><td> <a href="print.html#ex-url-base">Create a base URL by removing path segments</a> </td><td> <a href="https://docs.rs/url/"><img src="https://img.shields.io/crates/v/url.svg?label=url" alt="url-badge" /></a> </td><td> <a href="https://crates.io/categories/network-programming"><img src="https://img.shields.io/badge/-net-red.svg" alt="cat-net-badge" /></a> </td></tr>
<tr><td> <a href="print.html#ex-url-new-from-base">Create new URLs from a base URL</a> </td><td> <a href="https://docs.rs/url/"><img src="https://img.shields.io/crates/v/url.svg?label=url" alt="url-badge" /></a> </td><td> <a href="https://crates.io/categories/network-programming"><img src="https://img.shields.io/badge/-net-red.svg" alt="cat-net-badge" /></a> </td></tr>
<tr><td> <a href="print.html#ex-url-origin">Extract the URL origin (scheme / host / port)</a> </td><td> <a href="https://docs.rs/url/"><img src="https://img.shields.io/crates/v/url.svg?label=url" alt="url-badge" /></a> </td><td> <a href="https://crates.io/categories/network-programming"><img src="https://img.shields.io/badge/-net-red.svg" alt="cat-net-badge" /></a> </td></tr>
<tr><td> <a href="print.html#ex-url-rm-frag">Remove fragment identifiers and query pairs from a URL</a> </td><td> <a href="https://docs.rs/url/"><img src="https://img.shields.io/crates/v/url.svg?label=url" alt="url-badge" /></a> </td><td> <a href="https://crates.io/categories/network-programming"><img src="https://img.shields.io/badge/-net-red.svg" alt="cat-net-badge" /></a> </td></tr>
<tr><td> <a href="print.html#ex-url-basic">Make a HTTP GET request</a> </td><td> <a href="https://docs.rs/reqwest/"><img src="https://img.shields.io/crates/v/reqwest.svg?label=reqwest" alt="reqwest-badge" /></a> </td><td> <a href="https://crates.io/categories/network-programming"><img src="https://img.shields.io/badge/-net-red.svg" alt="cat-net-badge" /></a> </td></tr>
<tr><td> <a href="print.html#ex-url-download">Download a file to a temporary directory</a> </td><td> <a href="https://docs.rs/reqwest/"><img src="https://img.shields.io/crates/v/reqwest.svg?label=reqwest" alt="reqwest-badge" /></a> <a href="https://docs.rs/tempdir/"><img src="https://img.shields.io/crates/v/tempdir.svg?label=tempdir" alt="tempdir-badge" /></a> </td><td> <a href="https://crates.io/categories/network-programming"><img src="https://img.shields.io/badge/-net-red.svg" alt="cat-net-badge" /></a> <a href="https://crates.io/categories/filesystem"><img src="https://img.shields.io/badge/-filesystem-red.svg" alt="cat-filesystem-badge" /></a> </td></tr>
<tr><td> <a href="print.html#ex-rest-get">Query the GitHub API</a> </td><td> <a href="https://docs.rs/reqwest/"><img src="https://img.shields.io/crates/v/reqwest.svg?label=reqwest" alt="reqwest-badge" /></a> <a href="https://docs.rs/serde/"><img src="https://img.shields.io/crates/v/serde.svg?label=serde" alt="serde-badge" /></a> </td><td> <a href="https://crates.io/categories/network-programming"><img src="https://img.shields.io/badge/-net-red.svg" alt="cat-net-badge" /></a> <a href="https://crates.io/categories/encoding"><img src="https://img.shields.io/badge/-encoding-red.svg" alt="cat-encoding-badge" /></a> </td></tr>
<tr><td> <a href="print.html#ex-rest-head">Check if an API Resource Exists</a> </td><td> <a href="https://docs.rs/reqwest/"><img src="https://img.shields.io/crates/v/reqwest.svg?label=reqwest" alt="reqwest-badge" /></a> </td><td> <a href="https://crates.io/categories/network-programming"><img src="https://img.shields.io/badge/-net-red.svg" alt="cat-net-badge" /></a> </td></tr>
<tr><td> <a href="print.html#ex-rest-post">Create and delete Gist with GitHub API</a> </td><td> <a href="https://docs.rs/reqwest/"><img src="https://img.shields.io/crates/v/reqwest.svg?label=reqwest" alt="reqwest-badge" /></a> <a href="https://docs.rs/serde/"><img src="https://img.shields.io/crates/v/serde.svg?label=serde" alt="serde-badge" /></a> </td><td> <a href="https://crates.io/categories/network-programming"><img src="https://img.shields.io/badge/-net-red.svg" alt="cat-net-badge" /></a> <a href="https://crates.io/categories/encoding"><img src="https://img.shields.io/badge/-encoding-red.svg" alt="cat-encoding-badge" /></a> </td></tr>
<tr><td> <a href="print.html#ex-random-port-tcp">Listen on Unused port TCP/IP</a> </td><td> <a href="https://doc.rust-lang.org/std"><img src="https://img.shields.io/badge/std-1.17.0-blue.svg" alt="std-badge" /></a> </td><td> <a href="https://crates.io/categories/network-programming"><img src="https://img.shields.io/badge/-net-red.svg" alt="cat-net-badge" /></a> </td></tr>
</tbody></table>
<p><a name="ex-url-parse"/></p>
<a class="header" href="print.html#parse-a-url-from-a-string-to-a-url-type" id="parse-a-url-from-a-string-to-a-url-type"><h2>Parse a URL from a string to a <code>Url</code> type</h2></a>
<p><a href="https://docs.rs/url/"><img src="https://img.shields.io/crates/v/url.svg?label=url" alt="url-badge" /></a> <a href="https://crates.io/categories/network-programming"><img src="https://img.shields.io/badge/-net-red.svg" alt="cat-net-badge" /></a></p>
<p>The <a href="https://docs.rs/url/1.*/url/struct.Url.html#method.parse"><code>parse</code></a> method from the <code>url</code> crate validates and parses a <code>&amp;str</code> into a
<a href="https://docs.rs/url/1.*/url/struct.Url.html"><code>Url</code></a> struct. The input string may be malformed so this method returns
<code>Result&lt;Url, ParseError&gt;</code>.</p>
<p>Once the URL has been parsed, it can be used with all of the methods on the
<code>Url</code> type.</p>
<p>The URL in this code parses successfully, but swapping it out for a malformed
URL will print a message containing an explanation of what went wrong.</p>
<pre><pre class="playpen"><code class="language-rust"># #[macro_use]
# extern crate error_chain;
extern crate url;

use url::Url;
#
# error_chain! {
#    foreign_links {
#        UrlParse(url::ParseError);
#    }
# }

fn run() -&gt; Result&lt;()&gt; {
    let s = &quot;https://github.com/rust-lang/rust/issues?labels=E-easy&amp;state=open&quot;;

    let parsed = Url::parse(s)?;
    println!(&quot;The path part of the URL is: {}&quot;, parsed.path());

    Ok(())
}
#
# quick_main!(run);
</code></pre></pre>
<p><a name="ex-url-base"></a></p>
<a class="header" href="print.html#create-a-base-url-by-removing-path-segments" id="create-a-base-url-by-removing-path-segments"><h2>Create a base URL by removing path segments</h2></a>
<p><a href="https://docs.rs/url/"><img src="https://img.shields.io/crates/v/url.svg?label=url" alt="url-badge" /></a> <a href="https://crates.io/categories/network-programming"><img src="https://img.shields.io/badge/-net-red.svg" alt="cat-net-badge" /></a></p>
<pre><pre class="playpen"><code class="language-rust"># #[macro_use]
# extern crate error_chain;
extern crate url;

use url::Url;
#
# error_chain! {
#    foreign_links {
#        UrlParse(url::ParseError);
#    }
#    errors {
#        CannotBeABase
#    }
# }

fn run() -&gt; Result&lt;()&gt; {
    let full = &quot;https://github.com/rust-lang/cargo?asdf&quot;;

    let url = Url::parse(full)?;
    let base = base_url(url)?;

    assert_eq!(base.as_str(), &quot;https://github.com/&quot;);
    println!(&quot;The base of the URL is: {}&quot;, base);

    Ok(())
}

/// Returns the base of the given URL - the part not including any path segments
/// and query parameters.
fn base_url(mut url: Url) -&gt; Result&lt;Url&gt; {
    // Clear path segments.
    match url.path_segments_mut() {
        Ok(mut path) =&gt; {
            path.clear();
        }
        Err(_) =&gt; {
            // Certain URLs cannot be turned into a base URL.
            return Err(Error::from_kind(ErrorKind::CannotBeABase));
        }
    }

    // Clear query parameters.
    url.set_query(None);

    Ok(url)
}
#
# quick_main!(run);
</code></pre></pre>
<p><a name="ex-url-new-from-base"></a></p>
<a class="header" href="print.html#create-new-urls-from-a-base-url" id="create-new-urls-from-a-base-url"><h2>Create new URLs from a base URL</h2></a>
<p><a href="https://docs.rs/url/"><img src="https://img.shields.io/crates/v/url.svg?label=url" alt="url-badge" /></a> <a href="https://crates.io/categories/network-programming"><img src="https://img.shields.io/badge/-net-red.svg" alt="cat-net-badge" /></a></p>
<p>The <a href="https://docs.rs/url/1.*/url/struct.Url.html#method.join"><code>join</code></a> method creates a new URL from a base and relative path.</p>
<pre><pre class="playpen"><code class="language-rust"># #[macro_use]
# extern crate error_chain;
extern crate url;

use url::Url;
#
# error_chain! {
#    foreign_links {
#        UrlParse(url::ParseError);
#    }
# }

fn run() -&gt; Result&lt;()&gt; {
    let path = &quot;/rust-lang/cargo&quot;;

    let gh = build_github_url(path)?;

    assert_eq!(gh.as_str(), &quot;https://github.com/rust-lang/cargo&quot;);
    println!(&quot;The joined URL is: {}&quot;, gh);

    Ok(())
}

fn build_github_url(path: &amp;str) -&gt; Result&lt;Url&gt; {
    // Hardcoded in our program. Caller's path will be joined to this.
    const GITHUB: &amp;'static str = &quot;https://github.com&quot;;

    let base = Url::parse(GITHUB).expect(&quot;hardcoded URL is known to be valid&quot;);
    let joined = base.join(path)?;

    Ok(joined)
}
#
# quick_main!(run);
</code></pre></pre>
<p><a name="ex-url-origin"></a></p>
<a class="header" href="print.html#extract-the-url-origin-scheme--host--port" id="extract-the-url-origin-scheme--host--port"><h2>Extract the URL origin (scheme / host / port)</h2></a>
<p><a href="https://docs.rs/url/"><img src="https://img.shields.io/crates/v/url.svg?label=url" alt="url-badge" /></a> <a href="https://crates.io/categories/network-programming"><img src="https://img.shields.io/badge/-net-red.svg" alt="cat-net-badge" /></a></p>
<p>The <a href="https://docs.rs/url/1.*/url/struct.Url.html"><code>Url</code></a> struct exposes various methods to extract information about the URL
it represents.</p>
<pre><pre class="playpen"><code class="language-rust"># #[macro_use]
# extern crate error_chain;
extern crate url;

use url::{Url, Host};

# error_chain! {
#    foreign_links {
#        UrlParse(url::ParseError);
#    }
# }
#
fn run() -&gt; Result&lt;()&gt; {
    let s = &quot;ftp://rust-lang.org/examples&quot;;

    let url = Url::parse(s)?;

    assert_eq!(url.scheme(), &quot;ftp&quot;);
    assert_eq!(url.host(), Some(Host::Domain(&quot;rust-lang.org&quot;)));
    assert_eq!(url.port_or_known_default(), Some(21));
    println!(&quot;The origin is as expected!&quot;);

    Ok(())
}
#
# quick_main!(run);
</code></pre></pre>
<p>The same result can be obtained using the <a href="https://docs.rs/url/1.*/url/struct.Url.html#method.origin"><code>origin</code></a> method as well.</p>
<pre><pre class="playpen"><code class="language-rust"># #[macro_use]
# extern crate error_chain;
extern crate url;

use url::{Url, Origin, Host};

# error_chain! {
#    foreign_links {
#        UrlParse(url::ParseError);
#    }
# }
#
fn run() -&gt; Result&lt;()&gt; {
    let s = &quot;ftp://rust-lang.org/examples&quot;;

    let url = Url::parse(s)?;

    let expected_scheme = &quot;ftp&quot;.to_owned();
    let expected_host = Host::Domain(&quot;rust-lang.org&quot;.to_owned());
    let expected_port = 21;
    let expected = Origin::Tuple(expected_scheme, expected_host, expected_port);

    let origin = url.origin();
    assert_eq!(origin, expected);
    println!(&quot;The origin is as expected!&quot;);

    Ok(())
}
#
# quick_main!(run);
</code></pre></pre>
<p><a name="ex-url-rm-frag"></a></p>
<a class="header" href="print.html#remove-fragment-identifiers-and-query-pairs-from-a-url" id="remove-fragment-identifiers-and-query-pairs-from-a-url"><h2>Remove fragment identifiers and query pairs from a URL</h2></a>
<p><a href="https://docs.rs/url/"><img src="https://img.shields.io/crates/v/url.svg?label=url" alt="url-badge" /></a> <a href="https://crates.io/categories/network-programming"><img src="https://img.shields.io/badge/-net-red.svg" alt="cat-net-badge" /></a></p>
<p>Once <a href="https://docs.rs/url/1.*/url/struct.Url.html"><code>Url</code></a> is parsed it can be sliced with <a href="https://docs.rs/url/*/url/enum.Position.html"><code>url::Position</code></a> to strip unneeded URL parts.</p>
<pre><pre class="playpen"><code class="language-rust"># #[macro_use]
# extern crate error_chain;
extern crate url;

use url::{Url, Position};
#
# error_chain! {
#    foreign_links {
#        UrlParse(url::ParseError);
#    }
# }

fn run() -&gt; Result&lt;()&gt; {
    let parsed = Url::parse(&quot;https://github.com/rust-lang/rust/issues?labels=E-easy&amp;state=open&quot;)?;
    let cleaned: &amp;str = &amp;parsed[..Position::AfterPath];
    println!(&quot;cleaned: {}&quot;, cleaned);
    Ok(())
}
#
# quick_main!(run);
</code></pre></pre>
<p><a name="ex-url-basic"></a></p>
<a class="header" href="print.html#make-a-http-get-request" id="make-a-http-get-request"><h2>Make a HTTP GET request</h2></a>
<p><a href="https://docs.rs/reqwest/"><img src="https://img.shields.io/crates/v/reqwest.svg?label=reqwest" alt="reqwest-badge" /></a> <a href="https://crates.io/categories/network-programming"><img src="https://img.shields.io/badge/-net-red.svg" alt="cat-net-badge" /></a></p>
<p>The <a href="https://docs.rs/reqwest/*/reqwest/fn.get.html"><code>reqwest::get</code></a> function parses the supplied url and makes a
synchronous HTTP GET request. Obtained <a href="https://docs.rs/reqwest/*/reqwest/struct.Response.html"><code>reqwest::Response</code></a>
status and headers are printed. HTTP response body is read into an allocated <a href="https://doc.rust-lang.org/std/string/struct.String.html"><code>String</code></a> via <a href="https://doc.rust-lang.org/std/io/trait.Read.html#method.read_to_string"><code>read_to_string</code></a>.</p>
<pre><pre class="playpen"><code class="language-rust no_run"># #[macro_use]
# extern crate error_chain;
extern crate reqwest;

use std::io::Read;
#
# error_chain! {
#    foreign_links {
#        Io(std::io::Error);
#        HttpReqest(reqwest::Error);
#    }
# }

fn run() -&gt; Result&lt;()&gt; {
    let mut res = reqwest::get(&quot;http://httpbin.org/get&quot;)?;
    let mut body = String::new();
    res.read_to_string(&amp;mut body)?;

    println!(&quot;Status: {}&quot;, res.status());
    println!(&quot;Headers:\n{}&quot;, res.headers());
    println!(&quot;Body:\n{}&quot;, body);

    Ok(())
}
#
# quick_main!(run);
</code></pre></pre>
<p><a name="ex-url-download"></a></p>
<a class="header" href="print.html#download-a-file-to-a-temporary-directory" id="download-a-file-to-a-temporary-directory"><h2>Download a file to a temporary directory</h2></a>
<p><a href="https://docs.rs/reqwest/"><img src="https://img.shields.io/crates/v/reqwest.svg?label=reqwest" alt="reqwest-badge" /></a> <a href="https://docs.rs/tempdir/"><img src="https://img.shields.io/crates/v/tempdir.svg?label=tempdir" alt="tempdir-badge" /></a> <a href="https://crates.io/categories/network-programming"><img src="https://img.shields.io/badge/-net-red.svg" alt="cat-net-badge" /></a> <a href="https://crates.io/categories/filesystem"><img src="https://img.shields.io/badge/-filesystem-red.svg" alt="cat-filesystem-badge" /></a></p>
<p>Temporary directory is created with <a href="https://docs.rs/tempdir/*/tempdir/struct.TempDir.html#method.new"><code>TempDir::new</code></a> and a file is synchronously
downloaded over HTTP using <a href="https://docs.rs/reqwest/*/reqwest/fn.get.html"><code>reqwest::get</code></a>.
Target <a href="https://doc.rust-lang.org/std/fs/struct.File.html"><code>File</code></a> with name obtained from <a href="https://docs.rs/reqwest/*/reqwest/struct.Response.html#method.url"><code>Response::url</code></a> is created within <a href="https://docs.rs/tempdir/*/tempdir/struct.TempDir.html#method.path"><code>TempDir::path</code></a>
and downloaded data is copied into it with <a href="https://doc.rust-lang.org/std/io/fn.copy.html"><code>io::copy</code></a>. The temporary directory is implicitly removed on <code>run</code> function return.</p>
<pre><pre class="playpen"><code class="language-rust no_run"># #[macro_use]
# extern crate error_chain;
extern crate reqwest;
extern crate tempdir;

use std::io::copy;
use std::fs::File;
use tempdir::TempDir;
#
# error_chain! {
#    foreign_links {
#        Io(std::io::Error);
#        HttpReqest(reqwest::Error);
#    }
# }

fn run() -&gt; Result&lt;()&gt; {
    // create a temp dir with prefix &quot;example&quot;
    let tmp_dir = TempDir::new(&quot;example&quot;)?;
    // make HTTP request for remote content
    let target = &quot;https://www.rust-lang.org/logos/rust-logo-512x512.png&quot;;
    let mut response = reqwest::get(target)?;

    let mut dest = {
        // extract target filename from URL
        let fname = response.url()
            .path_segments()
            .and_then(|segments| segments.last())
            .and_then(|name| if name.is_empty() { None } else { Some(name) })
            .unwrap_or(&quot;tmp.bin&quot;);

        println!(&quot;file to download: '{}'&quot;, fname);
        let fname = tmp_dir.path().join(fname);
        println!(&quot;will be located under: '{:?}'&quot;, fname);
        // create file with given name inside the temp dir
        File::create(fname)?
    };
    // data is copied into the target file
    copy(&amp;mut response, &amp;mut dest)?;
    // tmp_dir is implicitly removed
    Ok(())
}
#
# quick_main!(run);
</code></pre></pre>
<p><a name="ex-rest-get"/></p>
<a class="header" href="print.html#query-the-github-api" id="query-the-github-api"><h2>Query the GitHub API</h2></a>
<p><a href="https://docs.rs/reqwest/"><img src="https://img.shields.io/crates/v/reqwest.svg?label=reqwest" alt="reqwest-badge" /></a> <a href="https://docs.rs/serde/"><img src="https://img.shields.io/crates/v/serde.svg?label=serde" alt="serde-badge" /></a> <a href="https://crates.io/categories/network-programming"><img src="https://img.shields.io/badge/-net-red.svg" alt="cat-net-badge" /></a> <a href="https://crates.io/categories/encoding"><img src="https://img.shields.io/badge/-encoding-red.svg" alt="cat-encoding-badge" /></a></p>
<p>GitHub <a href="https://developer.github.com/v3/activity/starring/#list-stargazers">stargazers API v3</a> is queried with <a href="https://docs.rs/reqwest/*/reqwest/fn.get.html"><code>reqwest::get</code></a> to obtain list of all users who have marked a GitHub project with a star. <a href="https://docs.rs/reqwest/*/reqwest/struct.Response.html"><code>reqwest::Response</code></a> is deserialized with <a href="https://docs.rs/reqwest/*/reqwest/struct.Response.html#method.json"><code>Response::json</code></a> into <code>User</code> objects implementing <a href="https://docs.rs/serde/*/serde/trait.Deserialize.html"><code>serde::Deserialize</code></a>.</p>
<pre><pre class="playpen"><code class="language-rust no_run"># #[macro_use]
# extern crate error_chain;
#[macro_use]
extern crate serde_derive;
extern crate reqwest;

#[derive(Deserialize, Debug)]
struct User {
    login: String,
    id: u32,
    // remaining fields not deserialized for brevity
}
#
# error_chain! {
#    foreign_links {
#        Reqwest(reqwest::Error);
#    }
# }

fn run() -&gt; Result&lt;()&gt; {
    let request_url = format!(&quot;https://api.github.com/repos/{owner}/{repo}/stargazers&quot;,
                              owner = &quot;brson&quot;,
                              repo = &quot;rust-cookbook&quot;);
    println!(&quot;{}&quot;, request_url);
    let mut response = reqwest::get(&amp;request_url)?;

    let users: Vec&lt;User&gt; = response.json()?;
    println!(&quot;{:?}&quot;, users);
    Ok(())
}
#
# quick_main!(run);
</code></pre></pre>
<p><a name="ex-rest-head"/></p>
<a class="header" href="print.html#check-if-a-resource-exists-using-a-head-request" id="check-if-a-resource-exists-using-a-head-request"><h2>Check if a resource exists using a HEAD request</h2></a>
<p><a href="https://docs.rs/reqwest/"><img src="https://img.shields.io/crates/v/reqwest.svg?label=reqwest" alt="reqwest-badge" /></a> <a href="https://crates.io/categories/network-programming"><img src="https://img.shields.io/badge/-net-red.svg" alt="cat-net-badge" /></a></p>
<p>Query the <a href="https://api.github.com/users">GitHub Users Endpoint</a> using a HEAD request and then inspect the
response code to determine success. This is a quick way to query a rest resource without
needing to receive a body. You can also configure the <a href="https://docs.rs/reqwest/*/reqwest/struct.Client.html"><code>reqwest::Client</code></a> to use a timeout
which ensures that a request will not last longer than what is passed to the timeout function.</p>
<pre><pre class="playpen"><code class="language-rust no_run"># #[macro_use]
# extern crate error_chain;
extern crate reqwest;

use std::time::Duration;
use reqwest::Client;
#
# error_chain! {
#    foreign_links {
#        Reqwest(reqwest::Error);
#    }
# }

fn run() -&gt; Result&lt;()&gt; {
    let request_url = &quot;https://api.github.com/users/ferris-the-crab&quot;;
    println!(&quot;{}&quot;, request_url);

    // The timeout for the request is set to 5 seconds.
    let timeout = Duration::new(5, 0);

    let mut client = Client::new()?;
    client.timeout(timeout);
    let response = client.head(request_url).send()?;

    if response.status().is_success() {
        println!(&quot;ferris-the-crab is a user!&quot;);
    } else {
        println!(&quot;ferris-the-crab is not a user!&quot;);
    }

    Ok(())
}
#
# quick_main!(run);
</code></pre></pre>
<p><a name="ex-rest-post"/></p>
<a class="header" href="print.html#create-and-delete-gist-with-github-api" id="create-and-delete-gist-with-github-api"><h2>Create and delete Gist with GitHub API</h2></a>
<p><a href="https://docs.rs/reqwest/"><img src="https://img.shields.io/crates/v/reqwest.svg?label=reqwest" alt="reqwest-badge" /></a> <a href="https://docs.rs/serde/"><img src="https://img.shields.io/crates/v/serde.svg?label=serde" alt="serde-badge" /></a> <a href="https://crates.io/categories/network-programming"><img src="https://img.shields.io/badge/-net-red.svg" alt="cat-net-badge" /></a> <a href="https://crates.io/categories/encoding"><img src="https://img.shields.io/badge/-encoding-red.svg" alt="cat-encoding-badge" /></a></p>
<p>HTTP POST request to <a href="https://developer.github.com/v3/gists/">gists API v3</a> is made with <a href="https://docs.rs/reqwest/*/reqwest/struct.Client.html"><code>reqwest::Client</code></a> in order to create a gist.
A request body is created with <a href="https://docs.rs/serde_json/*/serde_json/macro.json.html"><code>serde_json::json!</code></a> macro and
set set with <a href="https://docs.rs/reqwest/*/reqwest/struct.RequestBuilder.html#method.json"><code>RequestBuilder::json</code></a>.
Request is prepared with <a href="https://docs.rs/reqwest/*/reqwest/struct.Client.html#method.post"><code>Client::post</code></a>, authenticated with <a href="https://docs.rs/reqwest/*/reqwest/struct.RequestBuilder.html#method.basic_auth"><code>RequestBuilder::basic_auth</code></a> and synchronously executed with <a href="https://docs.rs/reqwest/*/reqwest/struct.RequestBuilder.html#method.send"><code>RequestBuilder::send</code></a>.</p>
<p>Gist is subsequently deleted with HTTP DELETE request prepared with <a href="https://docs.rs/reqwest/*/reqwest/struct.Client.html#method.delete"><code>Client::delete</code></a> and executed as before.</p>
<pre><pre class="playpen"><code class="language-rust no_run"># #[macro_use]
# extern crate error_chain;
extern crate reqwest;
#[macro_use]
extern crate serde_derive;
#[macro_use]
extern crate serde_json;

use std::env;
#
# error_chain! {
#   foreign_links {
#       EnvVar(env::VarError);
#       HttpReqest(reqwest::Error);
#   }
# }

#[derive(Deserialize, Debug)]
struct Gist {
    id: String,
    html_url: String,
    // remaining fields not deserialized for brevity
}

fn run() -&gt; Result&lt;()&gt; {
    let gh_user = env::var(&quot;GH_USER&quot;)?;
    let gh_pass = env::var(&quot;GH_PASS&quot;)?;

    // The type `gist_body` is `serde_json::Value`
    let gist_body = json!({
        &quot;description&quot;: &quot;the description for this gist&quot;,
        &quot;public&quot;: true,
        &quot;files&quot;: {
             &quot;main.rs&quot;: {
             &quot;content&quot;: r#&quot;fn main() { println!(&quot;hello world!&quot;);}&quot;#
            }
        }});

    // create the gist
    let request_url = &quot;https://api.github.com/gists&quot;;
    let client = reqwest::Client::new()?;
    let mut response = client
        .post(request_url)
        .basic_auth(gh_user.clone(), Some(gh_pass.clone()))
        .json(&amp;gist_body)
        .send()?;

    let gist: Gist = response.json()?;
    println!(&quot;Created {:?}&quot;, gist);

    // delete the gist
    let request_url = format!(&quot;{}/{}&quot;,request_url, gist.id);
    let client = reqwest::Client::new()?;
    let response = client
        .delete(&amp;request_url)
        .basic_auth(gh_user, Some(gh_pass))
        .send()?;

    println!(&quot;Gist {} deleted! Status code: {}&quot;,gist.id, response.status());
    Ok(())
}
#
# quick_main!(run);
</code></pre></pre>
<p><a name="ex-random-port-tcp"></a></p>
<a class="header" href="print.html#listen-on-unused-port-tcpip" id="listen-on-unused-port-tcpip"><h2>Listen on Unused port TCP/IP</h2></a>
<p><a href="https://doc.rust-lang.org/std"><img src="https://img.shields.io/badge/std-1.17.0-blue.svg" alt="std-badge" /></a> <a href="https://crates.io/categories/network-programming"><img src="https://img.shields.io/badge/-net-red.svg" alt="cat-net-badge" /></a></p>
<p>In this example, the port is displayed on the console, and the program will
listen until a request is made.</p>
<pre><pre class="playpen"><code class="language-rust "># #[macro_use]
# extern crate error_chain;
#
use std::net::{SocketAddrV4, Ipv4Addr, TcpListener};
use std::io::Read;

# error_chain! {
#    foreign_links {
#        Io(::std::io::Error);
#    }
# }
#
fn run() -&gt; Result&lt;()&gt; {
    let loopback = Ipv4Addr::new(127, 0, 0, 1);
    // Assigning port 0 requests the OS to assign a free port
    let socket = SocketAddrV4::new(loopback, 0);
    let listener = TcpListener::bind(socket)?;
    let port = listener.local_addr()?;
    println!(&quot;Listening on {}, access this port to end the program&quot;, port);
    let (mut tcp_stream, addr) = listener.accept()?;  //block  until requested
    println!(&quot;Connection received! {:?} is sending data.&quot;, addr);
    let mut input = String::new();
    // read from the socket until connection closed by client, discard byte count.
    let _ = tcp_stream.read_to_string(&amp;mut input)?;
    println!(&quot;{:?} says {}&quot;, addr, input);
    Ok(())
}
#
# quick_main!(run);
</code></pre></pre>
<p>The <code>std</code> library is leveraged to make a well formed IP/port with the
<a href="https://doc.rust-lang.org/std/net/struct.SocketAddrV4.html"><code>SocketAddrV4</code></a> and <a href="https://doc.rust-lang.org/std/net/struct.Ipv4Addr.html"><code>Ipv4Addr</code></a> structs.  An unused random port is requested
by passing 0 to <a href="https://doc.rust-lang.org/std/net/struct.TcpListener.html#method.bind"><code>TcpListener::bind</code></a>.  The assigned address is available via
<a href="https://doc.rust-lang.org/std/net/struct.TcpListener.html#method.local_addr"><code>TcpListener::local_addr</code></a>.</p>
<p><a href="https://doc.rust-lang.org/std/net/struct.TcpListener.html#method.accept"><code>TcpListener::accept</code></a> synchronously waits for an incoming connection and
returns a <code>(</code><a href="https://doc.rust-lang.org/std/net/struct.TcpStream.html"><code>TcpStream</code></a>,  <a href="https://doc.rust-lang.org/std/net/struct.SocketAddrV4.html"><code>SocketAddrV4</code></a><code>)</code> representing the request.
Reading on the socket with <a href="https://doc.rust-lang.org/std/io/trait.Read.html#method.read_to_string"><code>read_to_string</code></a> will wait until the connection is
closed which can be tested with <code>telnet ip port</code>.  For example, if the program
shows Listening on 127.0.0.1:11500, run</p>
<p><code>telnet 127.0.0.1 11500</code></p>
<p>After sending data in telnet press <code>ctrl-]</code> and type <code>quit</code>.</p>
<!-- Categories -->
<!-- Crates -->
<!-- Reference -->
<a class="header" href="print.html#application-development" id="application-development"><h1>Application development</h1></a>
<table><thead><tr><th> Recipe </th><th> Crates </th><th> Categories </th></tr></thead><tbody>
<tr><td> <a href="print.html#ex-clap-basic">Parse command line arguments</a> </td><td> <a href="https://docs.rs/clap/"><img src="https://img.shields.io/crates/v/clap.svg?label=clap" alt="clap-badge" /></a> </td><td> <a href="https://crates.io/categories/command-line-interface"><img src="https://img.shields.io/badge/-command_line-red.svg" alt="cat-command-line-badge" /></a> </td></tr>
<tr><td> <a href="print.html#ex-log-debug">Log a debug message to the console</a> </td><td> <a href="https://docs.rs/log/"><img src="https://img.shields.io/crates/v/log.svg?label=log" alt="log-badge" /></a> <a href="https://docs.rs/env_logger/"><img src="https://img.shields.io/crates/v/env_logger.svg?label=env_logger" alt="env_logger-badge" /></a> </td><td> <a href="https://crates.io/categories/debugging"><img src="https://img.shields.io/badge/-debugging-red.svg" alt="cat-debugging-badge" /></a> </td></tr>
<tr><td> <a href="print.html#ex-log-error">Log an error message to the console</a> </td><td> <a href="https://docs.rs/log/"><img src="https://img.shields.io/crates/v/log.svg?label=log" alt="log-badge" /></a> <a href="https://docs.rs/env_logger/"><img src="https://img.shields.io/crates/v/env_logger.svg?label=env_logger" alt="env_logger-badge" /></a> </td><td> <a href="https://crates.io/categories/debugging"><img src="https://img.shields.io/badge/-debugging-red.svg" alt="cat-debugging-badge" /></a> </td></tr>
<tr><td> <a href="print.html#ex-log-mod">Enable log levels per module</a> </td><td> <a href="https://docs.rs/log/"><img src="https://img.shields.io/crates/v/log.svg?label=log" alt="log-badge" /></a> <a href="https://docs.rs/env_logger/"><img src="https://img.shields.io/crates/v/env_logger.svg?label=env_logger" alt="env_logger-badge" /></a> </td><td> <a href="https://crates.io/categories/debugging"><img src="https://img.shields.io/badge/-debugging-red.svg" alt="cat-debugging-badge" /></a> </td></tr>
<tr><td> <a href="print.html#ex-log-custom-logger">Log messages with a custom logger</a> </td><td> <a href="https://docs.rs/log/"><img src="https://img.shields.io/crates/v/log.svg?label=log" alt="log-badge" /></a> </td><td> <a href="https://crates.io/categories/debugging"><img src="https://img.shields.io/badge/-debugging-red.svg" alt="cat-debugging-badge" /></a> </td></tr>
<tr><td> <a href="print.html#ex-log-syslog">Log to the Unix syslog</a> </td><td> <a href="https://docs.rs/log/"><img src="https://img.shields.io/crates/v/log.svg?label=log" alt="log-badge" /></a> <a href="https://docs.rs/syslog/"><img src="https://img.shields.io/crates/v/syslog.svg?label=syslog" alt="syslog-badge" /></a> </td><td> <a href="https://crates.io/categories/debugging"><img src="https://img.shields.io/badge/-debugging-red.svg" alt="cat-debugging-badge" /></a> </td></tr>
<tr><td> <a href="print.html#ex-log-custom">Log messages to a custom location</a> </td><td> <a href="https://docs.rs/log/"><img src="https://img.shields.io/crates/v/log.svg?label=log" alt="log-badge" /></a> </td><td> <a href="https://crates.io/categories/debugging"><img src="https://img.shields.io/badge/-debugging-red.svg" alt="cat-debugging-badge" /></a> </td></tr>
<tr><td> <a href="print.html#ex-tar-temp">Unzip a tarball to a temporary directory</a> </td><td> <a href="https://docs.rs/flate2/"><img src="https://img.shields.io/crates/v/flate2.svg?label=flate2" alt="flate2-badge" /></a> <a href="https://docs.rs/tar/"><img src="https://img.shields.io/crates/v/tar.svg?label=tar" alt="tar-badge" /></a> <a href="https://docs.rs/tempdir/"><img src="https://img.shields.io/crates/v/tempdir.svg?label=tempdir" alt="tempdir-badge" /></a> </td><td> <a href="https://crates.io/categories/filesystem"><img src="https://img.shields.io/badge/-filesystem-red.svg" alt="cat-filesystem-badge" /></a> <a href="https://crates.io/categories/compression"><img src="https://img.shields.io/badge/-compression-red.svg" alt="cat-compression-badge" /></a> </td></tr>
<tr><td> <a href="print.html#ex-dedup-filenames">Recursively find duplicate file names</a> </td><td> <a href="https://docs.rs/walkdir/"><img src="https://img.shields.io/crates/v/walkdir.svg?label=walkdir" alt="walkdir-badge" /></a> </td><td> <a href="https://crates.io/categories/filesystem"><img src="https://img.shields.io/badge/-filesystem-red.svg" alt="cat-filesystem-badge" /></a> </td></tr>
<tr><td> <a href="print.html#ex-file-predicate">Recursively find all files with given predicate</a> </td><td> <a href="https://docs.rs/walkdir/"><img src="https://img.shields.io/crates/v/walkdir.svg?label=walkdir" alt="walkdir-badge" /></a> </td><td> <a href="https://crates.io/categories/filesystem"><img src="https://img.shields.io/badge/-filesystem-red.svg" alt="cat-filesystem-badge" /></a> </td></tr>
</tbody></table>
<p><a name="ex-clap-basic"></a></p>
<a class="header" href="print.html#parse-command-line-arguments" id="parse-command-line-arguments"><h2>Parse command line arguments</h2></a>
<p><a href="https://docs.rs/clap/"><img src="https://img.shields.io/crates/v/clap.svg?label=clap" alt="clap-badge" /></a> <a href="https://crates.io/categories/command-line-interface"><img src="https://img.shields.io/badge/-command_line-red.svg" alt="cat-command-line-badge" /></a></p>
<pre><pre class="playpen"><code class="language-rust">extern crate clap;

use clap::{Arg, App};

fn main() {
    // Define command line arguments.
    let matches = App::new(&quot;My Test Program&quot;)
        .version(&quot;0.1.0&quot;)
        .author(&quot;Hackerman Jones &lt;hckrmnjones@hack.gov&gt;&quot;)
        .about(&quot;Teaches argument parsing&quot;)
        .arg(Arg::with_name(&quot;file&quot;)
                 .short(&quot;f&quot;)
                 .long(&quot;file&quot;)
                 .takes_value(true)
                 .help(&quot;A cool file&quot;))
        .arg(Arg::with_name(&quot;num&quot;)
                 .short(&quot;n&quot;)
                 .long(&quot;number&quot;)
                 .takes_value(true)
                 .help(&quot;Five less than your favorite number&quot;))
        .get_matches();

    // Get value for file, or default to 'input.txt'.
    let myfile = matches.value_of(&quot;file&quot;).unwrap_or(&quot;input.txt&quot;);
    println!(&quot;The file passed is: {}&quot;, myfile);

    // Get value for num if present, and try parsing it as i32.
    let num_str = matches.value_of(&quot;num&quot;);
    match num_str {
        None =&gt; println!(&quot;No idea what your favorite number is.&quot;),
        Some(s) =&gt; {
            match s.parse::&lt;i32&gt;() {
                Ok(n) =&gt; println!(&quot;Your favorite number must be {}.&quot;, n + 5),
                Err(_) =&gt; println!(&quot;That's not a number! {}&quot;, s),
            }
        }
    }
}
</code></pre></pre>
<p>The <code>clap</code> crate is a simple-to-use, efficient, and full-featured library for
parsing command line arguments and subcommands when writing console/terminal
applications.</p>
<p>The application can describe the structure of its command-line interface using
<code>clap</code>'s builder style. The <a href="https://docs.rs/clap/">documentation</a> gives two other possible ways to
instantiate an application.</p>
<p>In the builder style, <code>with_name</code> is the unique identifier that <code>value_of</code> will
use to retrieve the value passed. The <code>short</code> and <code>long</code> options control the
flag the user will be expected to type; short flags look like <code>-f</code> and long
flags look like <code>--file</code>.</p>
<p>Usage information is generated by <code>clap</code>. The usage for the example application
looks like this.</p>
<pre><code>My Test Program 0.1.0
Hackerman Jones &lt;hckrmnjones@hack.gov&gt;
Teaches argument parsing

USAGE:
    testing [OPTIONS]

FLAGS:
    -h, --help       Prints help information
    -V, --version    Prints version information

OPTIONS:
    -f, --file &lt;file&gt;     A cool file
    -n, --number &lt;num&gt;    Five less than your favorite number
</code></pre>
<p>We can test the application by running a command like the following.</p>
<pre><code>$ cargo run -- -f myfile.txt -n 251
</code></pre>
<p>The output is:</p>
<pre><code>The file passed is: myfile.txt
Your favorite number must be 256.
</code></pre>
<p><a name="ex-log-debug"></a></p>
<a class="header" href="print.html#log-a-debug-message-to-the-console" id="log-a-debug-message-to-the-console"><h2>Log a debug message to the console</h2></a>
<p><a href="https://docs.rs/log/"><img src="https://img.shields.io/crates/v/log.svg?label=log" alt="log-badge" /></a> <a href="https://docs.rs/env_logger/"><img src="https://img.shields.io/crates/v/env_logger.svg?label=env_logger" alt="env_logger-badge" /></a> <a href="https://crates.io/categories/debugging"><img src="https://img.shields.io/badge/-debugging-red.svg" alt="cat-debugging-badge" /></a></p>
<p><a href="https://github.com/brson/rust-cookbook/issues/61">Write me!</a></p>
<p><a name="ex-log-error"></a></p>
<a class="header" href="print.html#log-an-error-message-to-the-console" id="log-an-error-message-to-the-console"><h2>Log an error message to the console</h2></a>
<p><a href="https://docs.rs/log/"><img src="https://img.shields.io/crates/v/log.svg?label=log" alt="log-badge" /></a> <a href="https://docs.rs/env_logger/"><img src="https://img.shields.io/crates/v/env_logger.svg?label=env_logger" alt="env_logger-badge" /></a> <a href="https://crates.io/categories/debugging"><img src="https://img.shields.io/badge/-debugging-red.svg" alt="cat-debugging-badge" /></a></p>
<p><a href="https://github.com/brson/rust-cookbook/issues/61">Write me!</a></p>
<p><a name="ex-log-mod"></a></p>
<a class="header" href="print.html#enable-log-levels-per-module" id="enable-log-levels-per-module"><h2>Enable log levels per module</h2></a>
<p><a href="https://docs.rs/log/"><img src="https://img.shields.io/crates/v/log.svg?label=log" alt="log-badge" /></a> <a href="https://docs.rs/env_logger/"><img src="https://img.shields.io/crates/v/env_logger.svg?label=env_logger" alt="env_logger-badge" /></a> <a href="https://crates.io/categories/debugging"><img src="https://img.shields.io/badge/-debugging-red.svg" alt="cat-debugging-badge" /></a></p>
<pre><pre class="playpen"><code class="language-rust"># #[macro_use]
# extern crate error_chain;
#[macro_use]
extern crate log;
extern crate env_logger;

mod foo {
    mod bar {
        pub fn run() {
            warn!(&quot;[bar] warn&quot;);
            info!(&quot;[bar] info&quot;);
            debug!(&quot;[bar] debug&quot;);
        }
    }

    pub fn run() {
        warn!(&quot;[foo] warn&quot;);
        info!(&quot;[foo] info&quot;);
        debug!(&quot;[foo] debug&quot;);
        bar::run();
    }
}
#
# error_chain! {
#    foreign_links {
#        SetLogger(log::SetLoggerError);
#    }
# }

fn run() -&gt; Result&lt;()&gt; {
    env_logger::init()?;
    warn!(&quot;[root] warn&quot;);
    info!(&quot;[root] info&quot;);
    debug!(&quot;[root] debug&quot;);
    foo::run();

    Ok(())
}
#
# quick_main!(run);
</code></pre></pre>
<p><a href="https://docs.rs/env_logger/"><code>env_logger</code></a> output is controlled by <a href="https://doc.rust-lang.org/log/env_logger/#enabling-logging"><code>RUST_LOG</code></a> environmental
variable on per module basis with comma separated entries in format <code>path::to::module=log_level</code>.
Assuming application <code>test</code> is run as follows:</p>
<pre><code>RUST_LOG=&quot;warn,test::foo=info,test::foo::bar=debug&quot; ./test
</code></pre>
<p>The default <a href="https://doc.rust-lang.org/log/log/enum.LogLevel.html"><code>log::LogLevel</code></a> is set to <code>warn</code>, while log levels for module <code>foo</code> and nested module <code>foo::bar</code> are set respectively to <code>info</code> and <code>debug</code>.</p>
<p>The output is:</p>
<pre><code>WARN:test: [root] warn
WARN:test::foo: [foo] warn
INFO:test::foo: [foo] info
WARN:test::foo::bar: [bar] warn
INFO:test::foo::bar: [bar] info
DEBUG:test::foo::bar: [bar] debug
</code></pre>
<p><a name="ex-log-custom-logger"></a></p>
<a class="header" href="print.html#log-messages-with-a-custom-logger" id="log-messages-with-a-custom-logger"><h2>Log messages with a custom logger</h2></a>
<p><a href="https://docs.rs/log/"><img src="https://img.shields.io/crates/v/log.svg?label=log" alt="log-badge" /></a> <a href="https://crates.io/categories/debugging"><img src="https://img.shields.io/badge/-debugging-red.svg" alt="cat-debugging-badge" /></a></p>
<p>Custom logger <code>ConsoleLogger</code> is implemented with <a href="https://doc.rust-lang.org/log/log/trait.Log.html"><code>log::Log</code></a> trait and installed
via <a href="https://doc.rust-lang.org/log/log/fn.set_logger.html"><code>log::set_logger</code></a>. Messages are logged to stdout.</p>
<pre><pre class="playpen"><code class="language-rust"># #[macro_use]
# extern crate error_chain;
#[macro_use]
extern crate log;

use log::{LogRecord, LogLevel, LogMetadata, LogLevelFilter};

struct ConsoleLogger;

impl log::Log for ConsoleLogger {
    fn enabled(&amp;self, metadata: &amp;LogMetadata) -&gt; bool {
        metadata.level() &lt;= LogLevel::Info
    }

    fn log(&amp;self, record: &amp;LogRecord) {
        if self.enabled(record.metadata()) {
            println!(&quot;Rust says: {} - {}&quot;, record.level(), record.args());
        }
    }
}
#
# error_chain! {
#    foreign_links {
#        SetLogger(log::SetLoggerError);
#    }
# }

fn run() -&gt; Result&lt;()&gt; {
    log::set_logger(|max_log_level| {
                        max_log_level.set(LogLevelFilter::Info);
                        Box::new(ConsoleLogger)
                    })?;

    info!(&quot;hello log&quot;);
    warn!(&quot;warning&quot;);
    error!(&quot;oops&quot;);
    Ok(())
}
#
# quick_main!(run);
</code></pre></pre>
<p><a name="ex-log-syslog"></a></p>
<a class="header" href="print.html#log-to-the-unix-syslog" id="log-to-the-unix-syslog"><h2>Log to the Unix syslog</h2></a>
<p><a href="https://docs.rs/log/"><img src="https://img.shields.io/crates/v/log.svg?label=log" alt="log-badge" /></a> <a href="https://docs.rs/syslog/"><img src="https://img.shields.io/crates/v/syslog.svg?label=syslog" alt="syslog-badge" /></a> <a href="https://crates.io/categories/debugging"><img src="https://img.shields.io/badge/-debugging-red.svg" alt="cat-debugging-badge" /></a></p>
<p>Messages are logged to <a href="https://www.gnu.org/software/libc/manual/html_node/Overview-of-Syslog.html">UNIX syslog</a>. Logger backend is initialized
with <a href="https://docs.rs/syslog/*/syslog/fn.init.html"><code>syslog::init</code></a>.
<a href="https://docs.rs/syslog/*/syslog/enum.Facility.html"><code>syslog::Facility</code></a> indicates type of program submitting log.
<a href="https://doc.rust-lang.org/log/log/enum.LogLevelFilter.html"><code>log::LogLevelFilter</code></a> denotes allowed log verbosity
and <code>Option&lt;&amp;str&gt;</code> holds optional application name.</p>
<pre><pre class="playpen"><code class="language-rust no_run"># #[macro_use]
# extern crate error_chain;
#[macro_use]
extern crate log;
extern crate syslog;

use log::LogLevelFilter;
use syslog::Facility;
#
# error_chain! {
#    foreign_links {
#        SetLogger(log::SetLoggerError);
#    }
# }

fn run() -&gt; Result&lt;()&gt; {
    syslog::init(Facility::LOG_USER, LogLevelFilter::Debug, Some(&quot;My app name&quot;))?;
    debug!(&quot;this is a debug {}&quot;, &quot;message&quot;);
    error!(&quot;this is an error!&quot;);
    Ok(())
}
#
# quick_main!(run);
</code></pre></pre>
<p><a name="ex-log-custom"></a></p>
<a class="header" href="print.html#log-messages-to-a-custom-location" id="log-messages-to-a-custom-location"><h2>Log messages to a custom location</h2></a>
<p><a href="https://docs.rs/log/"><img src="https://img.shields.io/crates/v/log.svg?label=log" alt="log-badge" /></a> <a href="https://docs.rs/log4rs/"><img src="https://img.shields.io/crates/v/log4rs.svg?label=log4rs" alt="log4rs-badge" /></a> <a href="https://crates.io/categories/debugging"><img src="https://img.shields.io/badge/-debugging-red.svg" alt="cat-debugging-badge" /></a></p>
<p>Logs are configured to log to a custom location by using log4rs. log4rs can use either an external yaml file or a programmatically constructed configuration.</p>
<p>First log file configuration is created using <a href="https://docs.rs/log4rs/*/log4rs/append/file/struct.FileAppender.html"><code>log4rs::append::file::FileAppender</code></a> using a custom pattern from <a href="https://docs.rs/log4rs/*/log4rs/encode/pattern/index.html"><code>log4rs::encode::pattern</code></a>.</p>
<p>Then this is assigned to the <a href="https://docs.rs/log4rs/*/log4rs/config/struct.Config.html"><code>log4rs::config::Config</code></a> which has a root appender that uses the <code>logfile</code> appender that was just created, and sets the default <a href="https://doc.rust-lang.org/log/log/enum.LogLevelFilter.html"><code>log::LogLevelFilter</code></a> so that any logs with <code>Info</code> level or higher will be sent to the logger.</p>
<pre><pre class="playpen"><code class="language-rust no_run"># #[macro_use]
# extern crate error_chain;
#[macro_use]
extern crate log;
extern crate log4rs;

use log::LogLevelFilter;
use log4rs::append::file::FileAppender;
use log4rs::encode::pattern::PatternEncoder;
use log4rs::config::{Appender, Config, Root};
#
# error_chain! {
#    foreign_links {
#        Io(std::io::Error);
#        LogConfig(log4rs::config::Errors);
#        SetLogger(log::SetLoggerError);
#    }
# }

fn run() -&gt; Result&lt;()&gt; {
    let logfile = FileAppender::builder()
        .encoder(Box::new(PatternEncoder::new(&quot;{l} - {m}\n&quot;)))
        .build(&quot;log/output.log&quot;)?;

    let config = Config::builder()
        .appender(Appender::builder().build(&quot;logfile&quot;, Box::new(logfile)))
        .build(Root::builder().appender(&quot;logfile&quot;).build(LogLevelFilter::Info))?;

    log4rs::init_config(config)?;

    info!(&quot;Hello, world!&quot;);

    Ok(())
}
#
# quick_main!(run);
</code></pre></pre>
<p><a name="ex-tar-temp"></a></p>
<a class="header" href="print.html#unzip-a-tarball-to-a-temporary-directory" id="unzip-a-tarball-to-a-temporary-directory"><h2>Unzip a tarball to a temporary directory</h2></a>
<p><a href="https://docs.rs/flate2/"><img src="https://img.shields.io/crates/v/flate2.svg?label=flate2" alt="flate2-badge" /></a> <a href="https://docs.rs/tar/"><img src="https://img.shields.io/crates/v/tar.svg?label=tar" alt="tar-badge" /></a> <a href="https://docs.rs/tempdir/"><img src="https://img.shields.io/crates/v/tempdir.svg?label=tempdir" alt="tempdir-badge" /></a> <a href="https://crates.io/categories/filesystem"><img src="https://img.shields.io/badge/-filesystem-red.svg" alt="cat-filesystem-badge" /></a> <a href="https://crates.io/categories/compression"><img src="https://img.shields.io/badge/-compression-red.svg" alt="cat-compression-badge" /></a></p>
<p>Uncompress (<a href="https://docs.rs/flate2/0.2.19/flate2/read/struct.GzDecoder.html#method.new"><code>flate2::read::GzDecoder::new</code></a>) and
extract (<a href="https://docs.rs/tar/0.4.12/tar/struct.Archive.html#method.new"><code>tar::Archive::unpack</code></a>) all files form a zipped tarball
named archive.tar.gz located in the current working directory
inside a temporary directory (<a href="https://docs.rs/tempdir/0.3.5/tempdir/struct.TempDir.html#method.new"><code>tempdir::TempDir::new</code></a>)
and delete everything.</p>
<pre><pre class="playpen"><code class="language-rust no_run"># #[macro_use]
# extern crate error_chain;
extern crate flate2;
extern crate tar;
extern crate tempdir;

use std::fs::File;
use flate2::read::GzDecoder;
use tar::Archive;
use tempdir::TempDir;
#
# error_chain! {
#    foreign_links {
#        Io(std::io::Error);
#    }
# }

fn run() -&gt; Result&lt;()&gt; {
    let path = &quot;archive.tar.gz&quot;;

    // Open our zipped tarball
    let tar_gz = File::open(path)?;
    // Uncompressed it
    let tar = GzDecoder::new(tar_gz)?;
    // Load the archive from the tarball
    let mut archive = Archive::new(tar);
    // Create a directory inside of `std::env::temp_dir()`, named with
    // the prefix &quot;temp&quot;.
    let tmp_dir = TempDir::new(&quot;temp&quot;)?;
    // Unpack the archive inside the temporary directory
    archive.unpack(tmp_dir.path())?;

    Ok(())
}
#
# quick_main!(run);
</code></pre></pre>
<p><a name="ex-dedup-filenames"></a></p>
<a class="header" href="print.html#recursively-find-duplicate-file-names" id="recursively-find-duplicate-file-names"><h2>Recursively find duplicate file names</h2></a>
<p><a href="https://docs.rs/walkdir/"><img src="https://img.shields.io/crates/v/walkdir.svg?label=walkdir" alt="walkdir-badge" /></a> <a href="https://crates.io/categories/filesystem"><img src="https://img.shields.io/badge/-filesystem-red.svg" alt="cat-filesystem-badge" /></a></p>
<p>Find recusively in the current directory duplicate filenames,
printing them only once.</p>
<pre><pre class="playpen"><code class="language-rust no_run">extern crate walkdir;

use std::collections::HashMap;
use walkdir::WalkDir;

fn main() {
    // Counters indexed by filenames
    let mut filenames = HashMap::new();

    // List recusively all files in the current directory filtering out
    // directories and files not accessible (permission denied)
    for entry in WalkDir::new(&quot;.&quot;).into_iter()
                                  .filter_map(Result::ok)
                                  .filter(|e| !e.file_type().is_dir()) {
        // Get entry's filename
        let f_name = String::from(entry.file_name().to_string_lossy());
        // Get or initialize the counter
        let counter = filenames.entry(f_name.clone()).or_insert(0);
        // Update the counter
        *counter += 1;

        if *counter == 2 {
            println!(&quot;{}&quot;, f_name);
        }
    }
}
</code></pre></pre>
<p><a name="ex-file-predicate"></a></p>
<a class="header" href="print.html#recursively-find-all-files-with-given-predicate" id="recursively-find-all-files-with-given-predicate"><h2>Recursively find all files with given predicate</h2></a>
<p>Use the file names and metadata to recursively find in the current directory JSON files modified within the last day.</p>
<p><a href="https://docs.rs/walkdir/"><img src="https://img.shields.io/crates/v/walkdir.svg?label=walkdir" alt="walkdir-badge" /></a> <a href="https://crates.io/categories/filesystem"><img src="https://img.shields.io/badge/-filesystem-red.svg" alt="cat-filesystem-badge" /></a></p>
<pre><pre class="playpen"><code class="language-rust no_run"># #[macro_use]
# extern crate error_chain;
extern crate walkdir;

use walkdir::WalkDir;
#
# error_chain! {
#    foreign_links {
#        WalkDir(walkdir::Error);
#        Io(std::io::Error);
#        SystemTime(std::time::SystemTimeError);
#    }
# }

fn run() -&gt; Result&lt;()&gt; {
    // List recusively all accessible files in the current directory
    for entry in WalkDir::new(&quot;.&quot;).into_iter()
                                  .filter_map(|e| e.ok()) {
        // Get entry's filename
        let f_name = entry.file_name().to_string_lossy();
        // Get entry's modified time
        let sec = entry.metadata()?.modified()?;

        // Print JSON files modified within the last day
        if f_name.ends_with(&quot;.json&quot;) &amp;&amp; sec.elapsed()?.as_secs() &lt; 86400 {
            println!(&quot;{}&quot;, f_name);
        }
    }

    Ok(())
}
#
# quick_main!(run);
</code></pre></pre>
<!-- Categories -->
<!-- Crates -->
<!-- Reference -->

                </div>

                <!-- Mobile navigation buttons -->
                

                

            </div>

            

            

        </div>


        <!-- Local fallback for Font Awesome -->
        <script>
            if ($(".fa").css("font-family") !== "FontAwesome") {
                $('<link rel="stylesheet" type="text/css" href="_FontAwesome/css/font-awesome.css">').prependTo('head');
            }

            // START - Rust Cookbook customization
            $("#edit-button").click(function(){
                var editWindow = window.open("https://github.com/brson/rust-cookbook/edit/master/src/print.md");
            });
            // END - Rust Cookbook customization
        </script>

        <!-- Livereload script (if served using the cli tool) -->
        

        <script src="highlight.js"></script>
        <script src="book.js"></script>
    </body>
</html>
