<!DOCTYPE HTML>
<html lang="en">
    <head>
        <meta charset="UTF-8">
        <title>Networking - </title>
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">

        <base href="">

        <link rel="stylesheet" href="book.css">
        <link href="https://fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800" rel="stylesheet" type="text/css">
        <link href="https://fonts.googleapis.com/css?family=Source+Code+Pro:500" rel="stylesheet" type="text/css">

        <link rel="shortcut icon" href="favicon.png">

        <!-- Font Awesome -->
        <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/font-awesome/4.3.0/css/font-awesome.min.css">

        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">

        <!-- MathJax -->
        <script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>

        <!-- Fetch JQuery from CDN but have a local fallback -->
        <script src="https://code.jquery.com/jquery-2.1.4.min.js"></script>
        <script>
            if (typeof jQuery == 'undefined') {
                document.write(unescape("%3Cscript src='jquery.js'%3E%3C/script%3E"));
            }
        </script>
    </head>
    <body class="light">
        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme = localStorage.getItem('theme');
            if (theme == null) { theme = 'light'; }
            $('body').removeClass().addClass(theme);
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var sidebar = localStorage.getItem('sidebar');
            if (sidebar === "hidden") { $("html").addClass("sidebar-hidden") }
            else if (sidebar === "visible") { $("html").addClass("sidebar-visible") }
        </script>

        <div id="sidebar" class="sidebar">
            <ul class="chapter"><li class="affix"><a href="intro.html">Table of Contents</a></li><li class="affix"><a href="about.html">About</a></li><li><a href="basics.html"><strong>1.</strong> Basics</a></li><li><a href="encoding.html"><strong>2.</strong> Encoding</a></li><li><a href="concurrency.html"><strong>3.</strong> Concurrency</a></li><li><a href="net.html" class="active"><strong>4.</strong> Networking</a></li><li><a href="app.html"><strong>5.</strong> Application development</a></li></ul>
        </div>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar" class="menu-bar">
                    <div class="left-buttons">
                        <i id="sidebar-toggle" class="fa fa-bars"></i>
                        <!-- START - Rust Cookbook customization -->
                        <i id="edit-button" class="fa fa-edit">Edit</i>
                        <!-- END - Rust Cookbook customization -->
                        <i id="theme-toggle" class="fa fa-paint-brush"></i>
                    </div>

                    <h1 class="menu-title"></h1>

                    <div class="right-buttons">
                        <i id="print-button" class="fa fa-print" title="Print this book"></i>
                    </div>
                </div>

                <div id="content" class="content">
                    <a class="header" href="net.html#networking" id="networking"><h1>Networking</h1></a>
<table><thead><tr><th> Recipe </th><th> Crates </th><th> Categories </th></tr></thead><tbody>
<tr><td> <a href="net.html#ex-url-parse">Parse a URL from a string to a <code>Url</code> type</a> </td><td> <a href="https://docs.rs/url/"><img src="https://img.shields.io/crates/v/url.svg?label=url" alt="url-badge" /></a> </td><td> <a href="https://crates.io/categories/network-programming"><img src="https://img.shields.io/badge/-net-red.svg" alt="cat-net-badge" /></a> </td></tr>
<tr><td> <a href="net.html#ex-url-base">Create a base URL by removing path segments</a> </td><td> <a href="https://docs.rs/url/"><img src="https://img.shields.io/crates/v/url.svg?label=url" alt="url-badge" /></a> </td><td> <a href="https://crates.io/categories/network-programming"><img src="https://img.shields.io/badge/-net-red.svg" alt="cat-net-badge" /></a> </td></tr>
<tr><td> <a href="net.html#ex-url-new-from-base">Create new URLs from a base URL</a> </td><td> <a href="https://docs.rs/url/"><img src="https://img.shields.io/crates/v/url.svg?label=url" alt="url-badge" /></a> </td><td> <a href="https://crates.io/categories/network-programming"><img src="https://img.shields.io/badge/-net-red.svg" alt="cat-net-badge" /></a> </td></tr>
<tr><td> <a href="net.html#ex-url-origin">Extract the URL origin (scheme / host / port)</a> </td><td> <a href="https://docs.rs/url/"><img src="https://img.shields.io/crates/v/url.svg?label=url" alt="url-badge" /></a> </td><td> <a href="https://crates.io/categories/network-programming"><img src="https://img.shields.io/badge/-net-red.svg" alt="cat-net-badge" /></a> </td></tr>
<tr><td> <a href="net.html#ex-url-rm-frag">Remove fragment identifiers and query pairs from a URL</a> </td><td> <a href="https://docs.rs/url/"><img src="https://img.shields.io/crates/v/url.svg?label=url" alt="url-badge" /></a> </td><td> <a href="https://crates.io/categories/network-programming"><img src="https://img.shields.io/badge/-net-red.svg" alt="cat-net-badge" /></a> </td></tr>
<tr><td> <a href="net.html#ex-url-basic">Make a HTTP GET request</a> </td><td> <a href="https://docs.rs/reqwest/"><img src="https://img.shields.io/crates/v/reqwest.svg?label=reqwest" alt="reqwest-badge" /></a> </td><td> <a href="https://crates.io/categories/network-programming"><img src="https://img.shields.io/badge/-net-red.svg" alt="cat-net-badge" /></a> </td></tr>
<tr><td> <a href="net.html#ex-url-download">Download a file to a temporary directory</a> </td><td> <a href="https://docs.rs/reqwest/"><img src="https://img.shields.io/crates/v/reqwest.svg?label=reqwest" alt="reqwest-badge" /></a> <a href="https://docs.rs/tempdir/"><img src="https://img.shields.io/crates/v/tempdir.svg?label=tempdir" alt="tempdir-badge" /></a> </td><td> <a href="https://crates.io/categories/network-programming"><img src="https://img.shields.io/badge/-net-red.svg" alt="cat-net-badge" /></a> <a href="https://crates.io/categories/filesystem"><img src="https://img.shields.io/badge/-filesystem-red.svg" alt="cat-filesystem-badge" /></a> </td></tr>
<tr><td> <a href="net.html#ex-rest-get">Query the GitHub API</a> </td><td> <a href="https://docs.rs/reqwest/"><img src="https://img.shields.io/crates/v/reqwest.svg?label=reqwest" alt="reqwest-badge" /></a> <a href="https://docs.rs/serde/"><img src="https://img.shields.io/crates/v/serde.svg?label=serde" alt="serde-badge" /></a> </td><td> <a href="https://crates.io/categories/network-programming"><img src="https://img.shields.io/badge/-net-red.svg" alt="cat-net-badge" /></a> <a href="https://crates.io/categories/encoding"><img src="https://img.shields.io/badge/-encoding-red.svg" alt="cat-encoding-badge" /></a> </td></tr>
<tr><td> <a href="net.html#ex-rest-head">Check if an API Resource Exists</a> </td><td> <a href="https://docs.rs/reqwest/"><img src="https://img.shields.io/crates/v/reqwest.svg?label=reqwest" alt="reqwest-badge" /></a> </td><td> <a href="https://crates.io/categories/network-programming"><img src="https://img.shields.io/badge/-net-red.svg" alt="cat-net-badge" /></a> </td></tr>
<tr><td> <a href="net.html#ex-rest-post">Create and delete Gist with GitHub API</a> </td><td> <a href="https://docs.rs/reqwest/"><img src="https://img.shields.io/crates/v/reqwest.svg?label=reqwest" alt="reqwest-badge" /></a> <a href="https://docs.rs/serde/"><img src="https://img.shields.io/crates/v/serde.svg?label=serde" alt="serde-badge" /></a> </td><td> <a href="https://crates.io/categories/network-programming"><img src="https://img.shields.io/badge/-net-red.svg" alt="cat-net-badge" /></a> <a href="https://crates.io/categories/encoding"><img src="https://img.shields.io/badge/-encoding-red.svg" alt="cat-encoding-badge" /></a> </td></tr>
<tr><td> <a href="net.html#ex-random-port-tcp">Listen on Unused port TCP/IP</a> </td><td> <a href="https://doc.rust-lang.org/std"><img src="https://img.shields.io/badge/std-1.17.0-blue.svg" alt="std-badge" /></a> </td><td> <a href="https://crates.io/categories/network-programming"><img src="https://img.shields.io/badge/-net-red.svg" alt="cat-net-badge" /></a> </td></tr>
</tbody></table>
<p><a name="ex-url-parse"/></p>
<a class="header" href="net.html#parse-a-url-from-a-string-to-a-url-type" id="parse-a-url-from-a-string-to-a-url-type"><h2>Parse a URL from a string to a <code>Url</code> type</h2></a>
<p><a href="https://docs.rs/url/"><img src="https://img.shields.io/crates/v/url.svg?label=url" alt="url-badge" /></a> <a href="https://crates.io/categories/network-programming"><img src="https://img.shields.io/badge/-net-red.svg" alt="cat-net-badge" /></a></p>
<p>The <a href="https://docs.rs/url/1.*/url/struct.Url.html#method.parse"><code>parse</code></a> method from the <code>url</code> crate validates and parses a <code>&amp;str</code> into a
<a href="https://docs.rs/url/1.*/url/struct.Url.html"><code>Url</code></a> struct. The input string may be malformed so this method returns
<code>Result&lt;Url, ParseError&gt;</code>.</p>
<p>Once the URL has been parsed, it can be used with all of the methods on the
<code>Url</code> type.</p>
<p>The URL in this code parses successfully, but swapping it out for a malformed
URL will print a message containing an explanation of what went wrong.</p>
<pre><pre class="playpen"><code class="language-rust"># #[macro_use]
# extern crate error_chain;
extern crate url;

use url::Url;
#
# error_chain! {
#    foreign_links {
#        UrlParse(url::ParseError);
#    }
# }

fn run() -&gt; Result&lt;()&gt; {
    let s = &quot;https://github.com/rust-lang/rust/issues?labels=E-easy&amp;state=open&quot;;

    let parsed = Url::parse(s)?;
    println!(&quot;The path part of the URL is: {}&quot;, parsed.path());

    Ok(())
}
#
# quick_main!(run);
</code></pre></pre>
<p><a name="ex-url-base"></a></p>
<a class="header" href="net.html#create-a-base-url-by-removing-path-segments" id="create-a-base-url-by-removing-path-segments"><h2>Create a base URL by removing path segments</h2></a>
<p><a href="https://docs.rs/url/"><img src="https://img.shields.io/crates/v/url.svg?label=url" alt="url-badge" /></a> <a href="https://crates.io/categories/network-programming"><img src="https://img.shields.io/badge/-net-red.svg" alt="cat-net-badge" /></a></p>
<pre><pre class="playpen"><code class="language-rust"># #[macro_use]
# extern crate error_chain;
extern crate url;

use url::Url;
#
# error_chain! {
#    foreign_links {
#        UrlParse(url::ParseError);
#    }
#    errors {
#        CannotBeABase
#    }
# }

fn run() -&gt; Result&lt;()&gt; {
    let full = &quot;https://github.com/rust-lang/cargo?asdf&quot;;

    let url = Url::parse(full)?;
    let base = base_url(url)?;

    assert_eq!(base.as_str(), &quot;https://github.com/&quot;);
    println!(&quot;The base of the URL is: {}&quot;, base);

    Ok(())
}

/// Returns the base of the given URL - the part not including any path segments
/// and query parameters.
fn base_url(mut url: Url) -&gt; Result&lt;Url&gt; {
    // Clear path segments.
    match url.path_segments_mut() {
        Ok(mut path) =&gt; {
            path.clear();
        }
        Err(_) =&gt; {
            // Certain URLs cannot be turned into a base URL.
            return Err(Error::from_kind(ErrorKind::CannotBeABase));
        }
    }

    // Clear query parameters.
    url.set_query(None);

    Ok(url)
}
#
# quick_main!(run);
</code></pre></pre>
<p><a name="ex-url-new-from-base"></a></p>
<a class="header" href="net.html#create-new-urls-from-a-base-url" id="create-new-urls-from-a-base-url"><h2>Create new URLs from a base URL</h2></a>
<p><a href="https://docs.rs/url/"><img src="https://img.shields.io/crates/v/url.svg?label=url" alt="url-badge" /></a> <a href="https://crates.io/categories/network-programming"><img src="https://img.shields.io/badge/-net-red.svg" alt="cat-net-badge" /></a></p>
<p>The <a href="https://docs.rs/url/1.*/url/struct.Url.html#method.join"><code>join</code></a> method creates a new URL from a base and relative path.</p>
<pre><pre class="playpen"><code class="language-rust"># #[macro_use]
# extern crate error_chain;
extern crate url;

use url::Url;
#
# error_chain! {
#    foreign_links {
#        UrlParse(url::ParseError);
#    }
# }

fn run() -&gt; Result&lt;()&gt; {
    let path = &quot;/rust-lang/cargo&quot;;

    let gh = build_github_url(path)?;

    assert_eq!(gh.as_str(), &quot;https://github.com/rust-lang/cargo&quot;);
    println!(&quot;The joined URL is: {}&quot;, gh);

    Ok(())
}

fn build_github_url(path: &amp;str) -&gt; Result&lt;Url&gt; {
    // Hardcoded in our program. Caller's path will be joined to this.
    const GITHUB: &amp;'static str = &quot;https://github.com&quot;;

    let base = Url::parse(GITHUB).expect(&quot;hardcoded URL is known to be valid&quot;);
    let joined = base.join(path)?;

    Ok(joined)
}
#
# quick_main!(run);
</code></pre></pre>
<p><a name="ex-url-origin"></a></p>
<a class="header" href="net.html#extract-the-url-origin-scheme--host--port" id="extract-the-url-origin-scheme--host--port"><h2>Extract the URL origin (scheme / host / port)</h2></a>
<p><a href="https://docs.rs/url/"><img src="https://img.shields.io/crates/v/url.svg?label=url" alt="url-badge" /></a> <a href="https://crates.io/categories/network-programming"><img src="https://img.shields.io/badge/-net-red.svg" alt="cat-net-badge" /></a></p>
<p>The <a href="https://docs.rs/url/1.*/url/struct.Url.html"><code>Url</code></a> struct exposes various methods to extract information about the URL
it represents.</p>
<pre><pre class="playpen"><code class="language-rust"># #[macro_use]
# extern crate error_chain;
extern crate url;

use url::{Url, Host};

# error_chain! {
#    foreign_links {
#        UrlParse(url::ParseError);
#    }
# }
#
fn run() -&gt; Result&lt;()&gt; {
    let s = &quot;ftp://rust-lang.org/examples&quot;;

    let url = Url::parse(s)?;

    assert_eq!(url.scheme(), &quot;ftp&quot;);
    assert_eq!(url.host(), Some(Host::Domain(&quot;rust-lang.org&quot;)));
    assert_eq!(url.port_or_known_default(), Some(21));
    println!(&quot;The origin is as expected!&quot;);

    Ok(())
}
#
# quick_main!(run);
</code></pre></pre>
<p>The same result can be obtained using the <a href="https://docs.rs/url/1.*/url/struct.Url.html#method.origin"><code>origin</code></a> method as well.</p>
<pre><pre class="playpen"><code class="language-rust"># #[macro_use]
# extern crate error_chain;
extern crate url;

use url::{Url, Origin, Host};

# error_chain! {
#    foreign_links {
#        UrlParse(url::ParseError);
#    }
# }
#
fn run() -&gt; Result&lt;()&gt; {
    let s = &quot;ftp://rust-lang.org/examples&quot;;

    let url = Url::parse(s)?;

    let expected_scheme = &quot;ftp&quot;.to_owned();
    let expected_host = Host::Domain(&quot;rust-lang.org&quot;.to_owned());
    let expected_port = 21;
    let expected = Origin::Tuple(expected_scheme, expected_host, expected_port);

    let origin = url.origin();
    assert_eq!(origin, expected);
    println!(&quot;The origin is as expected!&quot;);

    Ok(())
}
#
# quick_main!(run);
</code></pre></pre>
<p><a name="ex-url-rm-frag"></a></p>
<a class="header" href="net.html#remove-fragment-identifiers-and-query-pairs-from-a-url" id="remove-fragment-identifiers-and-query-pairs-from-a-url"><h2>Remove fragment identifiers and query pairs from a URL</h2></a>
<p><a href="https://docs.rs/url/"><img src="https://img.shields.io/crates/v/url.svg?label=url" alt="url-badge" /></a> <a href="https://crates.io/categories/network-programming"><img src="https://img.shields.io/badge/-net-red.svg" alt="cat-net-badge" /></a></p>
<p>Once <a href="https://docs.rs/url/1.*/url/struct.Url.html"><code>Url</code></a> is parsed it can be sliced with <a href="https://docs.rs/url/*/url/enum.Position.html"><code>url::Position</code></a> to strip unneeded URL parts.</p>
<pre><pre class="playpen"><code class="language-rust"># #[macro_use]
# extern crate error_chain;
extern crate url;

use url::{Url, Position};
#
# error_chain! {
#    foreign_links {
#        UrlParse(url::ParseError);
#    }
# }

fn run() -&gt; Result&lt;()&gt; {
    let parsed = Url::parse(&quot;https://github.com/rust-lang/rust/issues?labels=E-easy&amp;state=open&quot;)?;
    let cleaned: &amp;str = &amp;parsed[..Position::AfterPath];
    println!(&quot;cleaned: {}&quot;, cleaned);
    Ok(())
}
#
# quick_main!(run);
</code></pre></pre>
<p><a name="ex-url-basic"></a></p>
<a class="header" href="net.html#make-a-http-get-request" id="make-a-http-get-request"><h2>Make a HTTP GET request</h2></a>
<p><a href="https://docs.rs/reqwest/"><img src="https://img.shields.io/crates/v/reqwest.svg?label=reqwest" alt="reqwest-badge" /></a> <a href="https://crates.io/categories/network-programming"><img src="https://img.shields.io/badge/-net-red.svg" alt="cat-net-badge" /></a></p>
<p>The <a href="https://docs.rs/reqwest/*/reqwest/fn.get.html"><code>reqwest::get</code></a> function parses the supplied url and makes a
synchronous HTTP GET request. Obtained <a href="https://docs.rs/reqwest/*/reqwest/struct.Response.html"><code>reqwest::Response</code></a>
status and headers are printed. HTTP response body is read into an allocated <a href="https://doc.rust-lang.org/std/string/struct.String.html"><code>String</code></a> via <a href="https://doc.rust-lang.org/std/io/trait.Read.html#method.read_to_string"><code>read_to_string</code></a>.</p>
<pre><pre class="playpen"><code class="language-rust no_run"># #[macro_use]
# extern crate error_chain;
extern crate reqwest;

use std::io::Read;
#
# error_chain! {
#    foreign_links {
#        Io(std::io::Error);
#        HttpReqest(reqwest::Error);
#    }
# }

fn run() -&gt; Result&lt;()&gt; {
    let mut res = reqwest::get(&quot;http://httpbin.org/get&quot;)?;
    let mut body = String::new();
    res.read_to_string(&amp;mut body)?;

    println!(&quot;Status: {}&quot;, res.status());
    println!(&quot;Headers:\n{}&quot;, res.headers());
    println!(&quot;Body:\n{}&quot;, body);

    Ok(())
}
#
# quick_main!(run);
</code></pre></pre>
<p><a name="ex-url-download"></a></p>
<a class="header" href="net.html#download-a-file-to-a-temporary-directory" id="download-a-file-to-a-temporary-directory"><h2>Download a file to a temporary directory</h2></a>
<p><a href="https://docs.rs/reqwest/"><img src="https://img.shields.io/crates/v/reqwest.svg?label=reqwest" alt="reqwest-badge" /></a> <a href="https://docs.rs/tempdir/"><img src="https://img.shields.io/crates/v/tempdir.svg?label=tempdir" alt="tempdir-badge" /></a> <a href="https://crates.io/categories/network-programming"><img src="https://img.shields.io/badge/-net-red.svg" alt="cat-net-badge" /></a> <a href="https://crates.io/categories/filesystem"><img src="https://img.shields.io/badge/-filesystem-red.svg" alt="cat-filesystem-badge" /></a></p>
<p>Temporary directory is created with <a href="https://docs.rs/tempdir/*/tempdir/struct.TempDir.html#method.new"><code>TempDir::new</code></a> and a file is synchronously
downloaded over HTTP using <a href="https://docs.rs/reqwest/*/reqwest/fn.get.html"><code>reqwest::get</code></a>.
Target <a href="https://doc.rust-lang.org/std/fs/struct.File.html"><code>File</code></a> with name obtained from <a href="https://docs.rs/reqwest/*/reqwest/struct.Response.html#method.url"><code>Response::url</code></a> is created within <a href="https://docs.rs/tempdir/*/tempdir/struct.TempDir.html#method.path"><code>TempDir::path</code></a>
and downloaded data is copied into it with <a href="https://doc.rust-lang.org/std/io/fn.copy.html"><code>io::copy</code></a>. The temporary directory is implicitly removed on <code>run</code> function return.</p>
<pre><pre class="playpen"><code class="language-rust no_run"># #[macro_use]
# extern crate error_chain;
extern crate reqwest;
extern crate tempdir;

use std::io::copy;
use std::fs::File;
use tempdir::TempDir;
#
# error_chain! {
#    foreign_links {
#        Io(std::io::Error);
#        HttpReqest(reqwest::Error);
#    }
# }

fn run() -&gt; Result&lt;()&gt; {
    // create a temp dir with prefix &quot;example&quot;
    let tmp_dir = TempDir::new(&quot;example&quot;)?;
    // make HTTP request for remote content
    let target = &quot;https://www.rust-lang.org/logos/rust-logo-512x512.png&quot;;
    let mut response = reqwest::get(target)?;

    let mut dest = {
        // extract target filename from URL
        let fname = response.url()
            .path_segments()
            .and_then(|segments| segments.last())
            .and_then(|name| if name.is_empty() { None } else { Some(name) })
            .unwrap_or(&quot;tmp.bin&quot;);

        println!(&quot;file to download: '{}'&quot;, fname);
        let fname = tmp_dir.path().join(fname);
        println!(&quot;will be located under: '{:?}'&quot;, fname);
        // create file with given name inside the temp dir
        File::create(fname)?
    };
    // data is copied into the target file
    copy(&amp;mut response, &amp;mut dest)?;
    // tmp_dir is implicitly removed
    Ok(())
}
#
# quick_main!(run);
</code></pre></pre>
<p><a name="ex-rest-get"/></p>
<a class="header" href="net.html#query-the-github-api" id="query-the-github-api"><h2>Query the GitHub API</h2></a>
<p><a href="https://docs.rs/reqwest/"><img src="https://img.shields.io/crates/v/reqwest.svg?label=reqwest" alt="reqwest-badge" /></a> <a href="https://docs.rs/serde/"><img src="https://img.shields.io/crates/v/serde.svg?label=serde" alt="serde-badge" /></a> <a href="https://crates.io/categories/network-programming"><img src="https://img.shields.io/badge/-net-red.svg" alt="cat-net-badge" /></a> <a href="https://crates.io/categories/encoding"><img src="https://img.shields.io/badge/-encoding-red.svg" alt="cat-encoding-badge" /></a></p>
<p>GitHub <a href="https://developer.github.com/v3/activity/starring/#list-stargazers">stargazers API v3</a> is queried with <a href="https://docs.rs/reqwest/*/reqwest/fn.get.html"><code>reqwest::get</code></a> to obtain list of all users who have marked a GitHub project with a star. <a href="https://docs.rs/reqwest/*/reqwest/struct.Response.html"><code>reqwest::Response</code></a> is deserialized with <a href="https://docs.rs/reqwest/*/reqwest/struct.Response.html#method.json"><code>Response::json</code></a> into <code>User</code> objects implementing <a href="https://docs.rs/serde/*/serde/trait.Deserialize.html"><code>serde::Deserialize</code></a>.</p>
<pre><pre class="playpen"><code class="language-rust no_run"># #[macro_use]
# extern crate error_chain;
#[macro_use]
extern crate serde_derive;
extern crate reqwest;

#[derive(Deserialize, Debug)]
struct User {
    login: String,
    id: u32,
    // remaining fields not deserialized for brevity
}
#
# error_chain! {
#    foreign_links {
#        Reqwest(reqwest::Error);
#    }
# }

fn run() -&gt; Result&lt;()&gt; {
    let request_url = format!(&quot;https://api.github.com/repos/{owner}/{repo}/stargazers&quot;,
                              owner = &quot;brson&quot;,
                              repo = &quot;rust-cookbook&quot;);
    println!(&quot;{}&quot;, request_url);
    let mut response = reqwest::get(&amp;request_url)?;

    let users: Vec&lt;User&gt; = response.json()?;
    println!(&quot;{:?}&quot;, users);
    Ok(())
}
#
# quick_main!(run);
</code></pre></pre>
<p><a name="ex-rest-head"/></p>
<a class="header" href="net.html#check-if-a-resource-exists-using-a-head-request" id="check-if-a-resource-exists-using-a-head-request"><h2>Check if a resource exists using a HEAD request</h2></a>
<p><a href="https://docs.rs/reqwest/"><img src="https://img.shields.io/crates/v/reqwest.svg?label=reqwest" alt="reqwest-badge" /></a> <a href="https://crates.io/categories/network-programming"><img src="https://img.shields.io/badge/-net-red.svg" alt="cat-net-badge" /></a></p>
<p>Query the <a href="https://api.github.com/users">GitHub Users Endpoint</a> using a HEAD request and then inspect the
response code to determine success. This is a quick way to query a rest resource without
needing to receive a body. You can also configure the <a href="https://docs.rs/reqwest/*/reqwest/struct.Client.html"><code>reqwest::Client</code></a> to use a timeout
which ensures that a request will not last longer than what is passed to the timeout function.</p>
<pre><pre class="playpen"><code class="language-rust no_run"># #[macro_use]
# extern crate error_chain;
extern crate reqwest;

use std::time::Duration;
use reqwest::Client;
#
# error_chain! {
#    foreign_links {
#        Reqwest(reqwest::Error);
#    }
# }

fn run() -&gt; Result&lt;()&gt; {
    let request_url = &quot;https://api.github.com/users/ferris-the-crab&quot;;
    println!(&quot;{}&quot;, request_url);

    // The timeout for the request is set to 5 seconds.
    let timeout = Duration::new(5, 0);

    let mut client = Client::new()?;
    client.timeout(timeout);
    let response = client.head(request_url).send()?;

    if response.status().is_success() {
        println!(&quot;ferris-the-crab is a user!&quot;);
    } else {
        println!(&quot;ferris-the-crab is not a user!&quot;);
    }

    Ok(())
}
#
# quick_main!(run);
</code></pre></pre>
<p><a name="ex-rest-post"/></p>
<a class="header" href="net.html#create-and-delete-gist-with-github-api" id="create-and-delete-gist-with-github-api"><h2>Create and delete Gist with GitHub API</h2></a>
<p><a href="https://docs.rs/reqwest/"><img src="https://img.shields.io/crates/v/reqwest.svg?label=reqwest" alt="reqwest-badge" /></a> <a href="https://docs.rs/serde/"><img src="https://img.shields.io/crates/v/serde.svg?label=serde" alt="serde-badge" /></a> <a href="https://crates.io/categories/network-programming"><img src="https://img.shields.io/badge/-net-red.svg" alt="cat-net-badge" /></a> <a href="https://crates.io/categories/encoding"><img src="https://img.shields.io/badge/-encoding-red.svg" alt="cat-encoding-badge" /></a></p>
<p>HTTP POST request to <a href="https://developer.github.com/v3/gists/">gists API v3</a> is made with <a href="https://docs.rs/reqwest/*/reqwest/struct.Client.html"><code>reqwest::Client</code></a> in order to create a gist.
A request body is created with <a href="https://docs.rs/serde_json/*/serde_json/macro.json.html"><code>serde_json::json!</code></a> macro and
set set with <a href="https://docs.rs/reqwest/*/reqwest/struct.RequestBuilder.html#method.json"><code>RequestBuilder::json</code></a>.
Request is prepared with <a href="https://docs.rs/reqwest/*/reqwest/struct.Client.html#method.post"><code>Client::post</code></a>, authenticated with <a href="https://docs.rs/reqwest/*/reqwest/struct.RequestBuilder.html#method.basic_auth"><code>RequestBuilder::basic_auth</code></a> and synchronously executed with <a href="https://docs.rs/reqwest/*/reqwest/struct.RequestBuilder.html#method.send"><code>RequestBuilder::send</code></a>.</p>
<p>Gist is subsequently deleted with HTTP DELETE request prepared with <a href="https://docs.rs/reqwest/*/reqwest/struct.Client.html#method.delete"><code>Client::delete</code></a> and executed as before.</p>
<pre><pre class="playpen"><code class="language-rust no_run"># #[macro_use]
# extern crate error_chain;
extern crate reqwest;
#[macro_use]
extern crate serde_derive;
#[macro_use]
extern crate serde_json;

use std::env;
#
# error_chain! {
#   foreign_links {
#       EnvVar(env::VarError);
#       HttpReqest(reqwest::Error);
#   }
# }

#[derive(Deserialize, Debug)]
struct Gist {
    id: String,
    html_url: String,
    // remaining fields not deserialized for brevity
}

fn run() -&gt; Result&lt;()&gt; {
    let gh_user = env::var(&quot;GH_USER&quot;)?;
    let gh_pass = env::var(&quot;GH_PASS&quot;)?;

    // The type `gist_body` is `serde_json::Value`
    let gist_body = json!({
        &quot;description&quot;: &quot;the description for this gist&quot;,
        &quot;public&quot;: true,
        &quot;files&quot;: {
             &quot;main.rs&quot;: {
             &quot;content&quot;: r#&quot;fn main() { println!(&quot;hello world!&quot;);}&quot;#
            }
        }});

    // create the gist
    let request_url = &quot;https://api.github.com/gists&quot;;
    let client = reqwest::Client::new()?;
    let mut response = client
        .post(request_url)
        .basic_auth(gh_user.clone(), Some(gh_pass.clone()))
        .json(&amp;gist_body)
        .send()?;

    let gist: Gist = response.json()?;
    println!(&quot;Created {:?}&quot;, gist);

    // delete the gist
    let request_url = format!(&quot;{}/{}&quot;,request_url, gist.id);
    let client = reqwest::Client::new()?;
    let response = client
        .delete(&amp;request_url)
        .basic_auth(gh_user, Some(gh_pass))
        .send()?;

    println!(&quot;Gist {} deleted! Status code: {}&quot;,gist.id, response.status());
    Ok(())
}
#
# quick_main!(run);
</code></pre></pre>
<p><a name="ex-random-port-tcp"></a></p>
<a class="header" href="net.html#listen-on-unused-port-tcpip" id="listen-on-unused-port-tcpip"><h2>Listen on Unused port TCP/IP</h2></a>
<p><a href="https://doc.rust-lang.org/std"><img src="https://img.shields.io/badge/std-1.17.0-blue.svg" alt="std-badge" /></a> <a href="https://crates.io/categories/network-programming"><img src="https://img.shields.io/badge/-net-red.svg" alt="cat-net-badge" /></a></p>
<p>In this example, the port is displayed on the console, and the program will
listen until a request is made.</p>
<pre><pre class="playpen"><code class="language-rust "># #[macro_use]
# extern crate error_chain;
#
use std::net::{SocketAddrV4, Ipv4Addr, TcpListener};
use std::io::Read;

# error_chain! {
#    foreign_links {
#        Io(::std::io::Error);
#    }
# }
#
fn run() -&gt; Result&lt;()&gt; {
    let loopback = Ipv4Addr::new(127, 0, 0, 1);
    // Assigning port 0 requests the OS to assign a free port
    let socket = SocketAddrV4::new(loopback, 0);
    let listener = TcpListener::bind(socket)?;
    let port = listener.local_addr()?;
    println!(&quot;Listening on {}, access this port to end the program&quot;, port);
    let (mut tcp_stream, addr) = listener.accept()?;  //block  until requested
    println!(&quot;Connection received! {:?} is sending data.&quot;, addr);
    let mut input = String::new();
    // read from the socket until connection closed by client, discard byte count.
    let _ = tcp_stream.read_to_string(&amp;mut input)?;
    println!(&quot;{:?} says {}&quot;, addr, input);
    Ok(())
}
#
# quick_main!(run);
</code></pre></pre>
<p>The <code>std</code> library is leveraged to make a well formed IP/port with the
<a href="https://doc.rust-lang.org/std/net/struct.SocketAddrV4.html"><code>SocketAddrV4</code></a> and <a href="https://doc.rust-lang.org/std/net/struct.Ipv4Addr.html"><code>Ipv4Addr</code></a> structs.  An unused random port is requested
by passing 0 to <a href="https://doc.rust-lang.org/std/net/struct.TcpListener.html#method.bind"><code>TcpListener::bind</code></a>.  The assigned address is available via
<a href="https://doc.rust-lang.org/std/net/struct.TcpListener.html#method.local_addr"><code>TcpListener::local_addr</code></a>.</p>
<p><a href="https://doc.rust-lang.org/std/net/struct.TcpListener.html#method.accept"><code>TcpListener::accept</code></a> synchronously waits for an incoming connection and
returns a <code>(</code><a href="https://doc.rust-lang.org/std/net/struct.TcpStream.html"><code>TcpStream</code></a>,  <a href="https://doc.rust-lang.org/std/net/struct.SocketAddrV4.html"><code>SocketAddrV4</code></a><code>)</code> representing the request.
Reading on the socket with <a href="https://doc.rust-lang.org/std/io/trait.Read.html#method.read_to_string"><code>read_to_string</code></a> will wait until the connection is
closed which can be tested with <code>telnet ip port</code>.  For example, if the program
shows Listening on 127.0.0.1:11500, run</p>
<p><code>telnet 127.0.0.1 11500</code></p>
<p>After sending data in telnet press <code>ctrl-]</code> and type <code>quit</code>.</p>
<!-- Categories -->
<!-- Crates -->
<!-- Reference -->

                </div>

                <!-- Mobile navigation buttons -->
                
                    <a href="concurrency.html" class="mobile-nav-chapters previous">
                        <i class="fa fa-angle-left"></i>
                    </a>
                

                
                    <a href="app.html" class="mobile-nav-chapters next">
                        <i class="fa fa-angle-right"></i>
                    </a>
                

            </div>

            
                <a href="concurrency.html" class="nav-chapters previous" title="You can navigate through the chapters using the arrow keys">
                    <i class="fa fa-angle-left"></i>
                </a>
            

            
                <a href="app.html" class="nav-chapters next" title="You can navigate through the chapters using the arrow keys">
                    <i class="fa fa-angle-right"></i>
                </a>
            

        </div>


        <!-- Local fallback for Font Awesome -->
        <script>
            if ($(".fa").css("font-family") !== "FontAwesome") {
                $('<link rel="stylesheet" type="text/css" href="_FontAwesome/css/font-awesome.css">').prependTo('head');
            }

            // START - Rust Cookbook customization
            $("#edit-button").click(function(){
                var editWindow = window.open("https://github.com/brson/rust-cookbook/edit/master/src/net.md");
            });
            // END - Rust Cookbook customization
        </script>

        <!-- Livereload script (if served using the cli tool) -->
        

        <script src="highlight.js"></script>
        <script src="book.js"></script>
    </body>
</html>
